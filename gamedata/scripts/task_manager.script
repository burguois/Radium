task_ini = ini_file("misc\\task_manager.ltx")
local random_task = nil

class "CRandomTask"
function CRandomTask:__init()
	--' Таблица проинициализированных квестов.
	self.task_info = {}
end
-- Save
function CRandomTask:save(packet)
	set_save_marker(packet, "save", false, "CRandomTask")
	local n = 0
	for k,v in pairs(self.task_info) do
		n = n + 1
	end
	packet:w_u16(n)
	for k,v in pairs(self.task_info) do
		packet:w_stringZ(k)
		self.task_info[k]:save(packet)
	end

	set_save_marker(packet, "save", true, "CRandomTask")
end
-- Load
function CRandomTask:load(reader)
	set_save_marker(reader, "load", false, "CRandomTask")

	local n = reader:r_u16()
	for i=1,n do
		local id = reader:r_stringZ()
		local obj = task_objects.CGeneralTask(id)
		obj:load(reader)
		self.task_info[id] = obj
	end

	set_save_marker(reader, "load", true, "CRandomTask")
end
--------------------------------------------------------------------------------

--' Выдача квеста игроку
function CRandomTask:give_task(task_id)
	printf("CRandomTask:give_task() task_id[%s]", tostring(task_id))

	if not task_ini:section_exist(task_id) then
		printf("There is no task [%s] in task ini_file or ini_file is not included!!!", task_id)
	end
	self.task_info[task_id] = task_objects.CGeneralTask(task_id)

	self.task_info[task_id]:give_task()
end

function CRandomTask:set_task_completed(task_id)
	if (self.task_info[task_id]) then 
		self.task_info[task_id].forced_status = "complete"
	end
end

function CRandomTask:set_task_failed(task_id)
	if (self.task_info[task_id]) then 
		self.task_info[task_id].forced_status = "fail"
	end
end

function CRandomTask:update()
	local task
	for k,v in pairs(self.task_info) do
		task = self.task_info[k]
		if (task.timeout and game.get_game_time():diffSec(task.timeout) > task.repeat_timeout) then 
			self.task_info[k] = nil
		end
	end
end 

--' Проверяем, не выполнен ли таск
function CRandomTask:task_complete(p1)
	local task = self.task_info[p1]
	if task == nil then
		return false
	end
	
	task:check_task(self)
	if (task.forced_status == "complete") then 
		task.last_check_task = "complete"
	elseif (task.forced_status == "fail") then 
		return false
	end
	if task.last_check_task == "complete" then
		task:give_reward()
		xr_statistic.inc_completed_quests_counter()
		task.status = "completed"
		if (task.repeat_timeout) then 
			task.timeout = game.get_game_time()
		else 
			self.task_info[p1] = nil
		end
		return true
	else
		return false
	end
end
--' Проверяем, не профейлен ли таск
function CRandomTask:task_fail(p1)
	local task = self.task_info[p1]
	if task == nil then
		return false
	end
	
	task:check_task(self)
	if (task.forced_status == "fail") then
		task.last_check_task = "fail"
	elseif (task.forced_status == "complete") then 
		return false
	end
	if (task.last_check_task == "fail") then
		xr_logic.pick_section_from_condlist(db.actor, db.actor, task.on_fail)
		news_manager.send_task(db.actor, "fail", task.t)
		task.status = "fail"
		if (task.repeat_timeout) then 
			task.timeout = game.get_game_time()
		else
			self.task_info[p1] = nil
		end
		return true
	elseif (task.last_check_task == "reversed") then
		xr_logic.pick_section_from_condlist(db.actor, db.actor, task.on_reversed)
		news_manager.send_task(db.actor, "reversed", task.t)
		task.status = "normal"
		return true
	end
	return false
end

function CRandomTask:task_callback(task, status)

end


function get_task_manager()
	if random_task == nil then
		random_task = CRandomTask()
	end
	return random_task
end

function task_complete(p1)
	return get_task_manager():task_complete(p1)
end
function task_fail(p1)
	return get_task_manager():task_fail(p1)
end
function task_callback(_task, state)
end

function clear_task_manager()
end