--'******************************************************
-- Edited by Alundaio
--'******************************************************

-- Zone space_restrictors monster squads are not allowed to switch_online inside
local exiled_zones = {
	"zat_a2_sr_no_assault",
	"jup_a6_sr_no_assault",
	"jup_b41_sr_no_assault"
}


local squad_behaviour_ini 	= ini_file("misc\\squad_behaviours.ltx")
local locations_ini			= ini_file("misc\\smart_terrain_masks.ltx")

--------------------
local level,alife,game_graph,math,pairs,tostring,tonumber = level,alife,game_graph,math,pairs,tostring,tonumber
--------------------


--***********************************************************************************************
--*										INITIALIZATION								  *
--***********************************************************************************************
class "sim_squad_scripted" (cse_alife_online_offline_group)
function sim_squad_scripted:__init(section) super (section)
	self.smart_id 			= nil
	self.board 				= sim_board.get_sim_board()
	self.current_spot_id 	= nil
	self.current_action 	= nil

	self.current_target_id	= nil

	self.assigned_target_id	= nil
	self.sound_manager 		= sound_manager.get_sound_manager("squad_"..self:section_name() )

	self.settings_id 		= self:section_name()

	self:init_squad()

	self:set_squad_behaviour()
end

function sim_squad_scripted:init_squad()
	self.player_id 			= utils.cfg_get_string(sim_board.squad_ltx, self.settings_id, "faction", self, true, "")
	self.action_condlist	= xr_logic.parse_condlist(self, "assign_action", "target_smart", utils.cfg_get_string(sim_board.squad_ltx, self.settings_id, "target_smart", self, false, "", ""))
	self.death_condlist		= xr_logic.parse_condlist(self, "death_condlist", "on_death", utils.cfg_get_string(sim_board.squad_ltx, self.settings_id, "on_death", self, false, "", ""))
	self.invulnerability	= xr_logic.parse_condlist(self, "invulnerability", "invulnerability", utils.cfg_get_string(sim_board.squad_ltx, self.settings_id, "invulnerability", self, false, "", ""))
	
	--[[
	local rel 				= utils.cfg_get_string(sim_board.squad_ltx, self.settings_id, "relationship", self, false, "")
	self.relationship_condlist = rel and xr_logic.parse_condlist(self, self.settings_id, "relationship",rel)
	
	if (self.relationship_condlist) then 
		local new_relation = xr_logic.pick_section_from_condlist(db.actor, self, self.relationship_condlist)
		if (new_relation) and (new_relation == "enemy" or new_relation == "friend" or new_relation == "neutral") then 
			rel = new_relation
		end
	end
	--]]
	
	self.relationship		= self.relationship or utils.cfg_get_string(sim_board.squad_ltx, self.settings_id, "relationship", self, false, "")
	self.sympathy			= utils.cfg_get_number(sim_board.squad_ltx, self.settings_id, "sympathy", self, false, nil)
	self.show_spot			= xr_logic.parse_condlist(self, "show_spot", "show_spot", utils.cfg_get_string(sim_board.squad_ltx, self.settings_id, "show_spot", self, false, "", "false"))

	self.always_walk 		= utils.cfg_get_bool(sim_board.squad_ltx, self.settings_id, "always_walk", self, false)
	self.always_arrived		= utils.cfg_get_bool(sim_board.squad_ltx, self.settings_id, "always_arrived", self, false)
	self:set_location_types_section("stalker_terrain")
	self:set_squad_sympathy()
end

function sim_squad_scripted:init_squad_on_load()
	--alun_utils.debug_write(self:name().."init_squad_on_load start")
	self:set_squad_sympathy()
	self.board:assign_squad_to_smart(self, self.smart_id)

	if self.smart_id ~= nil then
		self.board:enter_smart(self, self.smart_id, true)
	end
	self.need_to_reset_location_masks = true
	--alun_utils.debug_write(self:name().."init_squad_on_load end")
end

function sim_squad_scripted:set_squad_behaviour()
	self.behaviour		= {}
	local behaviour_section = utils.cfg_get_string(sim_board.squad_ltx, self.settings_id, "behaviour", self, false, "", self.player_id)
	if not squad_behaviour_ini:section_exist(behaviour_section) then
		abort("There is no section ["..behaviour_section.."] in 'misc\\squad_behaviours.ltx'")
	end
	local n = squad_behaviour_ini:line_count(behaviour_section)
	local result, prop_name, prop_condlist
	for j=0,n-1 do
		result, prop_name, prop_condlist = squad_behaviour_ini:r_line(behaviour_section,j,"","")
		self.behaviour[prop_name] = prop_condlist
	end
end

function sim_squad_scripted:find_open_smart()
	local actor = db.actor or alife():actor()
	local squad_count
	local sim_reg = simulation_objects.get_sim_obj_registry()
	for name,smart in pairs(self.board.smarts_by_names) do
		if (smart and not smart.disabled) then
			sim_reg:get_props(smart)
			for k,v in pairs(self.behaviour) do
				if (tonumber(v) > 0 and smart.props[k] and tonumber(smart.props[k]) > 0) then
					if (xr_logic.pick_section_from_condlist(actor , smart, smart.sim_avail,"find open smart") == "true" and smart:sim_available()) then
						if (game_graph():vertex(self.m_game_vertex_id):level_id() == game_graph():vertex(smart.m_game_vertex_id):level_id()) then
							squad_count = smart_terrain.smart_terrain_squad_count(self.board.smarts[smart.id].squads)
							if (squad_count < smart.max_population) then
								return smart
							end
						end
					end
				end
			end
		end
	end
end
--***********************************************************************************************
--*										SCRIPT_TARGET_SELECTION									*
--***********************************************************************************************

function sim_squad_scripted:get_script_target()
	local new_target = self.scripted_target or xr_logic.pick_section_from_condlist(db.actor, self, self.action_condlist)

	if new_target == nil then
		return nil
	end

	if new_target ~= self.last_target then
		self.last_target = new_target
		self.parsed_targets = utils.parse_names(new_target)

		if self.need_free_update ~= true then
			self.next_target = 1
		else
			self.need_free_update = false
		end
	end
	if self.parsed_targets[self.next_target] == nil then
		self.next_target = 1
	end


	local nt = self:pick_next_target()
	if nt == "nil" then
		return nil
	elseif nt == "loop" then
		self.next_target = 1
		nt = self:pick_next_target()
	end
	local point = self.board.smarts_by_names[nt]
	if (point == nil or point.disabled) then
		--abort("Incorrect next point [%s] for squad [%s]", tostring(nt),  tostring(self.id))
		return self.id
	end

	return point.id
end

function sim_squad_scripted:pick_next_target()
	return self.parsed_targets[self.next_target]
end

function sim_squad_scripted:check_squad_come_to_point()
	if self.parsed_targets == nil then
		return true
	end

	local next_target = self.next_target or 0
	if self.assigned_target_id ~= nil and self.smart_id == self.assigned_target_id then
		if self.parsed_targets[next_target+1] ~= nil then
			self.next_target = next_target+1
			return true
		end
	end
	return false
end

function sim_squad_scripted:update_current_action()
	local is_finished =	self.current_action:update(false)
	if not is_finished then
		return false
	end
	return true
end

function sim_squad_scripted:update()
	cse_alife_online_offline_group.update (self)

	self:refresh()

	if not (self.first_update) then
		self.first_update = true
		local sim = alife()
		local se_actor = sim:actor()
		local gg = game_graph()

		--alun_utils.printf("m_game_vertex_id=%s actor.m_game_vertex_id=%s",self.m_game_vertex_id,se_actor.m_game_vertex_id)
		if (se_actor and gg:valid_vertex_id(self.m_game_vertex_id) and gg:valid_vertex_id(se_actor.m_game_vertex_id)) then
			local level = sim:level_name(gg:vertex(self.m_game_vertex_id):level_id())
			local actor_level = sim:level_name(gg:vertex(se_actor.m_game_vertex_id):level_id())

			-- Disable any squad that is not on actor's level and not linked to actor's level through ai_tweaks\simulation_objects.ltx
			if (level ~= actor_level) then
				if not (string.find(simulation_objects.config:GetValue(actor_level,"target_maps",0,""),level)) then
					self.board.squads[self.id] = nil
					if (self.smart_id) then
						self.board.tmp_entered_squad[self.smart_id] = nil
						self.board.tmp_assigned_squad[self.smart_id] = nil
					end
					simulation_objects.get_sim_obj_registry():unregister(self)
					self.disabled = true
					--alun_utils.printf("%s disabled",self:name())
					return
				end
			end
		end
	end

	if (self.disabled) then
		return
	end

	self.sound_manager:update()
	self:check_invulnerability()
	simulation_objects.get_sim_obj_registry():update_avaliability(self)

	-- Delta
	local tg = time_global()

	if (self.dtimer and tg < self.dtimer) then
		return
	end
	
	if (axr_main) then axr_main.squad_on_update(self) end

	local se_actor = alife():actor()
	self.dist_to_actor = self.position:distance_to(se_actor.position)

	self.dtimer = tg + 500 + math.max(50, 0.0025 * self.dist_to_actor)
	--

	local script_target = self:get_script_target()
	if not (script_target) then
		self:generic_update()
		if self.need_to_reset_location_masks then
			self:set_location_types()
			self.need_to_reset_location_masks = false
		end
		return
	end

	local need_to_find_new_action = false
	if self.assigned_target_id ~= nil and self.assigned_target_id == script_target then
		if self.current_action ~= nil then
			if self.current_action.name == "stay_point" then
				if self:check_squad_come_to_point() then
					need_to_find_new_action = true
				else
					need_to_find_new_action = self:update_current_action()
				end
			else
				if self:update_current_action() then
					self:check_squad_come_to_point()
					need_to_find_new_action = true
				end
			end
		else
			self:check_squad_come_to_point()
			need_to_find_new_action = true
		end
	else
		if self.current_action == nil then
			need_to_find_new_action = true
		else
			if self.current_action.major == true then
				if self:update_current_action() then
					self:check_squad_come_to_point()
					need_to_find_new_action = true
				end
			else
				need_to_find_new_action = true
			end
		end
	end

	if need_to_find_new_action == true then
		self.assigned_target_id = script_target

		if self.current_action ~= nil then
			self.current_action:finalize()
			self.current_action = nil
		end
		self:get_next_action(false)
	end
	if self.need_to_reset_location_masks then
		self:set_location_types()
		self.need_to_reset_location_masks = false
	end
end



--***********************************************************************************************
--*										SIMULATION_TARGET_SELECTION								*
--***********************************************************************************************

function sim_squad_scripted:clear_assigned_target()
	self.assigned_target_id = nil
end

function sim_squad_scripted:assigned_target_avaliable()
	local target_obj = self.assigned_target_id and alife():object(self.assigned_target_id)
	if (target_obj == nil or self.assigned_target_id == self.id) then
		return false
	end

	-- In this case, you need to check population minus one, because squad already committed Smart.
	return target_obj:target_precondition(self,true)
end

local function can_help_actor(squad)
	if empty(xr_combat_ignore.fighting_with_actor_npcs) then
		return false
	end
	if game_graph():vertex(squad.m_game_vertex_id):level_id() ~= game_graph():vertex(alife():actor().m_game_vertex_id):level_id() then
		return false
	end

	-- Alundaio
	if (axr_main) then
		if (axr_main.squad_can_help_actor(squad)) then
			return true
		end
	end
	-- Alundaio


	if has_alife_info("sim_duty_help_harder") and squad:get_squad_community() == "duty" then
		return true
	elseif has_alife_info("sim_freedom_help_harder") and squad:get_squad_community() == "freedom" then
		return true
	elseif has_alife_info("sim_stalker_help_harder") and squad:get_squad_community() == "stalker" then
		return true
	end
	return false
end

local function get_help_target_id(squad)
	-- Alundaio
	local target_id = axr_main and axr_main.squad_assign_new_target(squad)
	if (target_id and alife():object(target_id)) then
		return target_id
	end
	-- End Alundaio

	--[[
	if not can_help_actor(squad) then
		return
	end

	local enemy_squad_id
	local target_squad
	for k,v in pairs (xr_combat_ignore.fighting_with_actor_npcs) do
		enemy_squad_id = alife():object(k).group_id
		if enemy_squad_id ~= nil then
			target_squad = alife():object(enemy_squad_id)
			if target_squad and squad.position:distance_to_sqr(target_squad.position) < 150^2 and
				game_relations.is_factions_enemies(squad:get_squad_community(), target_squad:get_squad_community()) then
				return enemy_squad_id
			end
		end
	end

	--]]

	return
end

-- This update is called for all squads with no scripted assigned target
function sim_squad_scripted:generic_update()
	local help_target_id = get_help_target_id(self)

	if help_target_id then
		self.assigned_target_id = help_target_id
		self.current_action = nil
		self:get_next_action(false)
		return
	end

	if (self.assigned_target_id == self.id) then
		self.assigned_target_id = nil
	end

	if (self.current_action) then
		-- Forces a reset on current action when a surge starts so squads go to highest prior target
		if (xr_conditions.surge_started()) then
			if not (self.surge_reset_action) then
				self.surge_reset_action = true
				self.assigned_target_id = nil
			end
		else
			self.surge_reset_action = nil
		end

		-- Evaluate current assigned target; make sure it is still valid
		local se_target = self.assigned_target_id and alife():object(self.assigned_target_id)
		if (se_target and simulation_objects.get_sim_obj_registry().objects[self.assigned_target_id] and se_target:target_precondition(self,true)) then
			-- If current action is not finished, then return
			if not (self.current_action:update(true)) then
				return
			end
		end
	end

	-- Currrent action is finished; finalize
	if (self.current_action) then
		self.current_action:finalize()
		self.current_action = nil
	end

	self.current_target_id = nil

	-- Find a new target
	local target = self.board:get_squad_target(self)
	if not (target) then
		target = self:find_open_smart() or self
	end

	self.assigned_target_id = target and target.id
	self:get_next_action(true)
end



--' Получение следующего экшна на выполнение
function sim_squad_scripted:get_next_action(under_simulation)
	local squad_target = self.assigned_target_id and alife():object(self.assigned_target_id)
	if self.current_target_id == nil then
		if squad_target == nil or squad_target:am_i_reached(self) then
			if squad_target ~= nil then
				squad_target:on_reach_target(self)
				squad_target:on_after_reach(self)
			end
			self.current_action = sim_squad_actions.stay_on_target(self)
			self.current_target_id = self.assigned_target_id
			self.current_action:make(under_simulation)
			return
		end
	end

	if (self.assigned_target_id == self.current_target_id) or self.assigned_target_id == nil then
		self.current_action = sim_squad_actions.stay_on_target(self)
		self.current_target_id = self.assigned_target_id
		self.current_action:make(under_simulation)
	else
		self.current_action = sim_squad_actions.reach_target(self)
		self.current_action:make(under_simulation)
	end
end

--***********************************************************************************************
--*										MEMBERS_CONTROL											*
--***********************************************************************************************
local function release_object(p)
	local sim = alife()
	local se_obj = p[1] and sim:object(p[1])
	if not (se_obj) then
		return true
	end

	if (se_obj.online) then
		se_obj:switch_offline()
		return false
	end

	if not (se_obj.marked_for_release) then
		sim:release(se_obj,true)
		se_obj.marked_for_release = true
	end

	return true
end

--' Удаление персонажей отряда
function sim_squad_scripted:remove_squad()
	local squad_npcs = {}
	for k in self:squad_members() do
		squad_npcs[k.id] = true
	end

	local sim = alife()
	local se_obj, obj
	local object_by_id = level.object_by_id
	for id,v in pairs(squad_npcs) do
		se_obj = sim:object(id)
		if se_obj then
			self:unregister_member(id)
			--create_delayed_event(id,"safe_release",1,release_object,id)
			sim:release(se_obj,true)
		end
	end
	self:hide()
end

function sim_squad_scripted:remove_npc(npc_id)
	local sim = alife()
	local npc = sim:object(npc_id)
	self:on_npc_death(npc)
	sim:release(npc, true)
	--create_delayed_event(npc:id(),"safe_release",1,release_object,npc:id())
end

function sim_squad_scripted:on_npc_death(npc)
	--printf("Squad %s. Killed member %s", tostring(self.id), npc.id)
	-- Alundaio
	if (axr_main) then axr_main.squad_on_npc_death(self,npc,killer) end
	-- End Alundaio
	self.sound_manager:unregister_npc(npc.id)
	self:unregister_member(npc.id)

	if self:npc_count() == 0 then
		if self.current_action ~= nil then
			self.current_action:finalize()
			self.current_action = nil
		end
		if self.death_condlist ~= nil then
			xr_logic.pick_section_from_condlist(db.actor, self, self.death_condlist)
		end
		self.board:exit_smart(self, self.smart_id)
		self.board:assign_squad_to_smart(self, nil)
		self:hide()
		return
	end
	self:refresh()
end
function sim_squad_scripted:assign_squad_member_to_smart(member_id, smart, old_smart_id)
	local obj = alife():object(member_id)
	if obj ~= nil then
		--printf("    npc [%s] smart [%s]", obj:name(), tostring(obj.m_smart_terrain_id))
		if obj.m_smart_terrain_id == self.smart_id then
			return
		end

		if obj.m_smart_terrain_id ~= 65535 and old_smart_id ~= nil and (obj.m_smart_terrain_id == old_smart_id) and self.board.smarts[old_smart_id] ~= nil then
			self.board.smarts[old_smart_id].smrt:unregister_npc(obj)
		end

		if smart ~= nil then
			smart:register_npc(obj)
		end
	end
end

function sim_squad_scripted:assign_smart(smart)
	local old_smart = self.smart_id
	self.smart_id = smart and smart.id
	for k in self:squad_members() do
		self:assign_squad_member_to_smart(k.id, smart, old_smart)
	end
end

function sim_squad_scripted:check_invulnerability()
	if self.online ~= true then
		return
	end
	local invulnerability = xr_logic.pick_section_from_condlist(db.actor, self, self.invulnerability) == "true"
	local npc_st
	local npc
	local object_by_id = level.object_by_id
	for k in self:squad_members() do
		npc_st = db.storage[k.id]
		npc = npc_st and npc_st.ini and npc_st.object
		if (npc) then
			if npc:invulnerable() ~= invulnerabilty and utils.cfg_get_string(npc_st.ini, npc_st.active_section, "invulnerable", npc, false, "", nil) == nil  then
				npc:invulnerable(invulnerability)
			end
		end
	end
end

function sim_squad_scripted:set_location_types_section (section)
	if locations_ini:section_exist(section) then
		local result, id, value	= locations_ini:r_line(section,0,"","")
		self:add_location_type(id)
	end
end
function sim_squad_scripted:set_location_types(new_smart_name)
	local default_location = "stalker_terrain"
	self:clear_location_types()

	local sim = alife()
	local target = self.assigned_target_id and sim:object(self.assigned_target_id)
	if (target and target:clsid() == clsid.smart_terrain) then
		self:set_location_types_section(default_location)
		local old_smart_name = self.smart_id and alife():object(self.smart_id) and alife():object(self.smart_id):name()
		if old_smart_name then
			self:set_location_types_section(old_smart_name)
		end

		if new_smart_name then
			self:set_location_types_section(new_smart_name)
		end
	else
		self:set_location_types_section("squad_terrain")

		local se_obj
		for k,v in pairs(simulation_objects.get_sim_obj_registry().objects) do
			se_obj = sim:object(k)
			if (se_obj and se_obj:clsid() == clsid.smart_terrain) then
				local props_base = se_obj.props and se_obj.props["base"]
				if (props_base and tonumber(props_base) == 0) then
					self:set_location_types_section(se_obj:name())
				end
			end
		end
	end
end

function sim_squad_scripted:add_squad_member(spawn_section, spawn_position, lv_id, gv_id)
	local spawn_sections_ltx = system_ini()
	local custom_data = utils.cfg_get_string(spawn_sections_ltx, spawn_section, "custom_data", self, false, "", "default_custom_data.ltx")
	if custom_data ~= "default_custom_data.ltx" then
		printf("INCORRECT npc_spawn_section USED [%s]. You cannot use npc with custom_data in squads", spawn_section)
	end

	local sim = alife()
	local obj = sim:create(spawn_section,spawn_position,lv_id,gv_id)

	self:register_member(obj.id)
	self.sound_manager:register_npc(obj.id)

	local actor = sim:actor()
	if (simulation_objects.is_on_the_same_level(obj, actor) and spawn_position:distance_to_sqr(actor.position) <= sim:switch_distance()^2) then
		db.spawned_vertex_by_id[obj.id] = lv_id
	end
	-- Alundaio
	if (axr_main) then axr_main.squad_on_add_npc(self,obj,spawn_section,spawn_position,lv_id,gv_id) end
	-- End Alundaio
	return obj.id
end

function sim_squad_scripted:create_npc(spawn_smart)
	local ini = system_ini()
	local spawn_sections = utils.parse_names(utils.cfg_get_string(ini, self.settings_id, "npc", self, false, "", ""))

	local spawn_point = utils.cfg_get_string(ini, self.settings_id, "spawn_point", self, false, "","self") or
						utils.cfg_get_string(spawn_smart.ini, smart_terrain.SMART_TERRAIN_SECT, "spawn_point", self, false,"","self")
	spawn_point = xr_logic.parse_condlist(self, "spawn_point", "spawn_point", spawn_point)
	spawn_point = xr_logic.pick_section_from_condlist(db.actor, self, spawn_point)

	local base_spawn_position = spawn_smart.position
	local base_lvi = spawn_smart.m_level_vertex_id
	local base_gvi = spawn_smart.m_game_vertex_id


	local spawn_vid = alun_utils.read_from_ini(ini,self.settings_id,"spawn_vid","string",nil) or alun_utils.read_from_ini(spawn_smart.ini,smart_terrain.SMART_TERRAIN_SECT,"spawn_vid","string",nil)
	spawn_vid = spawn_vid and xr_logic.pick_section_from_condlist(db.actor,self, xr_logic.parse_condlist(self,"spawn_vid","spawn_vid",spawn_vid))

	if (spawn_vid) then
		local vid = alun_utils.str_explode(spawn_vid,":")
		base_lvi = tonumber(vid[1])
		base_spawn_position = level.vertex_position(base_lvi)
		base_gvi = tonumber(vid[2])
	else
		if spawn_point ~= nil then
			if spawn_point == "self" then
				base_spawn_position = spawn_smart.position
				base_lvi = spawn_smart.m_level_vertex_id
				base_gvi = spawn_smart.m_game_vertex_id
			else
				base_spawn_position = patrol(spawn_point):point(0)
				base_lvi = patrol(spawn_point):level_vertex_id(0)
				base_gvi = patrol(spawn_point):game_vertex_id(0)
			end
		elseif spawn_smart.spawn_point ~= nil then
			base_spawn_position = patrol(spawn_smart.spawn_point):point(0)
			base_lvi = patrol(spawn_smart.spawn_point):level_vertex_id(0)
			base_gvi = patrol(spawn_smart.spawn_point):game_vertex_id(0)
		end
	end

	if #spawn_sections ~= 0 then
		for k,v in pairs(spawn_sections) do
			self:add_squad_member(v, base_spawn_position, base_lvi, base_gvi,k)
		end
	end

	local random_spawn = utils.cfg_get_string(ini, self.settings_id, "npc_random", self, false, "",nil)
	if random_spawn ~= nil then
		random_spawn 				= 	utils.parse_names(random_spawn)

		local count = alun_utils.read_from_ini(ini,self.settings_id,"npc_in_squad","string","1,2")
		count = alun_utils.str_explode(count,",")
		count[1] = count[1] and tonumber(count[1])
		count[2] = count[2] and tonumber(count[2]) or count[1]

		local random_count = count[1] and count[2] and math.random(count[1],count[2]) or math.random(1,2)
		local random_id
		for i = 1,random_count do
			random_id = math.random(1, #random_spawn)
			self:add_squad_member(random_spawn[random_id], base_spawn_position, base_lvi, base_gvi)
		end
	elseif #spawn_sections == 0 then
		abort("You are trying to spawn an empty squad [%s]!!!", self.settings_id)
	end


	self.smart_id = spawn_smart.id
	self:refresh()
end

function sim_squad_scripted:set_squad_sympathy(sympathy)
	local symp = sympathy or self.sympathy
	if(symp~=nil) then
		local npc
		local object_by_id = level.object_by_id
		for k in self:squad_members() do
			npc = db.storage[k.id] and db.storage[k.id].object or object_by_id(k.id)
			if(npc) then
				game_relations.set_npc_sympathy(npc, symp)
			else
				if(db.goodwill.sympathy==nil) then
					db.goodwill.sympathy = {}
				end
				db.goodwill.sympathy[k.id] = symp
			end
		end
	end
end
local function set_relation(npc1, npc2, new_relation)
	local goodwill = tonumber(new_relation) or new_relation == "enemy" and -1000 or new_relation == "friend" and 1000 or 0
	if npc1 and npc2 then
		npc1:force_set_goodwill(goodwill, npc2.id)
	else
		abort("Npc not set in goodwill function!!!")
	end
end

function sim_squad_scripted:set_squad_relation(relation)
	local rel = relation or self.relationship
	if(rel ~= nil) then
		local npc
		local sim = alife()
		local object_by_id = level.object_by_id
		for k in self:squad_members() do
			npc = db.storage[k.id] and db.storage[k.id].object or object_by_id(k.id)
			if(npc) then
				game_relations.set_npcs_relation(npc, db.actor, rel)
			else
				set_relation(sim:object(k.id), sim:actor(),rel)
			end
		end
	end
end

local function reset_animation(npc)
	local state_mgr = db.storage[npc:id()].state_mgr
	if state_mgr == nil then
		return
	end
	local planner = npc:motivation_action_manager()

	state_mgr.animation:set_state(nil, true)
	state_mgr.animation:set_control()
	state_mgr.animstate:set_state(nil, true)
	state_mgr.animstate:set_control()

	state_mgr:set_state("idle", nil, nil, nil, {fast_set = true})

	state_mgr:update()
	state_mgr:update()
	state_mgr:update()
	state_mgr:update()
	state_mgr:update()
	state_mgr:update()
	state_mgr:update()

	npc:set_body_state(move.standing)
	npc:set_mental_state(anim.free)

end

function sim_squad_scripted:set_squad_position(position)
	if self.online == false then
		self:force_change_position(position)
	end

	local cl_object
	local object_by_id = level.object_by_id
	for k in self:squad_members() do
		cl_object = object_by_id(k.id)
		if not (db.offline_objects[k.id]) then
			db.offline_objects[k.id] = {}
		end
		db.offline_objects[k.id].level_vertex_id = level.vertex_id(position)
		if cl_object then
			reset_animation(cl_object)
			cl_object:set_npc_position(position)
		else
			k.object.position = position
		end
	end
end

function sim_squad_scripted:has_detector()
	local sim = alife()
	local se_obj
	for k in self:squad_members() do
		se_obj = sim:object(k.id)
		if se_obj and se_obj:has_detector() then
			return true
		end
	end
	return false
end

function sim_squad_scripted:get_squad_community()
	local squad_community = squad_community_by_behaviour[self.player_id]
	if squad_community == nil then
		abort("squad community is 'nil' for player_id [%s]", self.player_id)
	end
	return squad_community
end

function sim_squad_scripted:has_items_to_sell()
	if not (self.online) then
		return false
	end
	local sim = alife()
	local st
	for k in self:squad_members() do
		st = db.storage[k.id]
		if (st and st.has_items_to_sell) then
			return true
		end
	end
	return false
end

--***********************************************************************************************
--*										SAVE\LOAD												*
--***********************************************************************************************

function sim_squad_scripted:STATE_Write(packet)
	cse_alife_online_offline_group.STATE_Write (self, packet)
	set_save_marker(packet, "save", false, "sim_squad_scripted")


	packet:w_stringZ(tostring(self.current_target_id))
	packet:w_stringZ(tostring(self.respawn_point_id))
	packet:w_stringZ(tostring(self.respawn_point_prop_section))
	packet:w_stringZ(tostring(self.smart_id))

	set_save_marker(packet, "save", true, "sim_squad_scripted")
end
function sim_squad_scripted:STATE_Read(packet, size)
	--alun_utils.debug_write( alun_utils.sr("\n%s:STATE_Read start",self:name()) )
	cse_alife_online_offline_group.STATE_Read (self, packet, size)
	set_save_marker(packet, "load", false, "sim_squad_scripted")

	self.current_target_id = packet:r_stringZ()
	if self.current_target_id == "nil" then
		self.current_target_id = nil
	else
		self.current_target_id = tonumber(self.current_target_id)
	end
	self.respawn_point_id = packet:r_stringZ()
	if self.respawn_point_id == "nil" then
		self.respawn_point_id = nil
	else
		self.respawn_point_id = tonumber(self.respawn_point_id)
	end
	self.respawn_point_prop_section = packet:r_stringZ()
	if self.respawn_point_prop_section == "nil" then
		self.respawn_point_prop_section = nil
	end
	self.smart_id = packet:r_stringZ()
	if self.smart_id == "nil" then
		self.smart_id = nil
	else
		self.smart_id = tonumber(self.smart_id)
	end

	self:init_squad_on_load()
	set_save_marker(packet, "load", true, "sim_squad_scripted")
	--alun_utils.debug_write( alun_utils.sr("%s:STATE_Read end",self:name()) )
end
--***********************************************************************************************
--*										SERVER_OBJECT											*
--***********************************************************************************************

function sim_squad_scripted:on_register()
	--alun_utils.debug_write( alun_utils.sr("%s:on_register start",self:name()) )
	cse_alife_online_offline_group.on_register( self )
	story_objects.check_spawn_ini_for_story_id(self)
	self.board.squads[self.id] = self
	simulation_objects.get_sim_obj_registry():register(self)
	--alun_utils.debug_write( alun_utils.sr("%s:on_register end",self:name()) )
end
function sim_squad_scripted:on_unregister()
	cse_alife_online_offline_group.on_unregister( self )
	unregister_story_object_by_id(self.id)
	if (axr_main) then axr_main.squad_on_unregister(self) end
	self.board.squads[self.id] = nil
	self.board:assign_squad_to_smart(self, nil)
	simulation_objects.get_sim_obj_registry():unregister(self)
	if self.respawn_point_id ~= nil then
		local smart = alife():object(self.respawn_point_id)
		if smart == nil then
			return
		end
		smart.already_spawned[self.respawn_point_prop_section].num = smart.already_spawned[self.respawn_point_prop_section].num - 1
	end
end
function sim_squad_scripted:can_switch_offline()
	if (axr_main) then
		if (axr_main.squad_can_switch_offline(self) == false) then
			return false
		end
	end
	return cse_alife_online_offline_group.can_switch_offline(self)
end
function sim_squad_scripted:can_switch_online()
	if not (db.actor) then
		return false 
	end

	if (not self.online and is_squad_monster[self.player_id]) then
		-- Check for exiled zones
		local zone
		for i,name in pairs(exiled_zones) do
			zone = db.zone_by_name[name]
			if (zone and zone:inside(self.position)) then
				return false
			end
		end
	end

	return cse_alife_online_offline_group.can_switch_online(self)
end
function sim_squad_scripted:switch_offline()
	cse_alife_online_offline_group.switch_offline(self)
end
function sim_squad_scripted:switch_online()
	cse_alife_online_offline_group.switch_online(self)
	--if (dev_debug) then
		--alun_utils.printf("sim_squad_scripted:switch_online() [%s]",self:name())
		--get_console():execute("flush")
	--end
end

--***********************************************************************************************
--*										MAP LOCATION											*
--***********************************************************************************************

is_squad_monster =
{
	["monster_predatory_day"] 	= true,
	["monster_predatory_night"] = true,
	["monster_vegetarian"] 		= true,
	["monster_zombied_day"] 	= true,
	["monster_zombied_night"] 	= true,
	["monster_special"] 		= true,
	["monster"]					= true
}

function sim_squad_scripted:refresh()
	if(self:commander_id()==nil) then
		self:hide()
		return
	end
	self:show()
end


function sim_squad_scripted:hide()
	if(self.current_spot_id==nil) or (self.spot_section==nil) then
		return
	end
	level.map_remove_object_spot(self.current_spot_id, self.spot_section)
	self.current_spot_id = nil
	self.spot_section = nil
end

function sim_squad_scripted:show()
	if self.show_disabled then
		self:hide()
		return
	end

    if(level.map_has_object_spot(self:commander_id(), "ui_pda2_trader_location")~=0) or
	(level.map_has_object_spot(self:commander_id(), "ui_pda2_mechanic_location")~=0) or
	(level.map_has_object_spot(self:commander_id(), "ui_pda2_scout_location")~=0) or
	(level.map_has_object_spot(self:commander_id(), "ui_pda2_quest_npc_location")~=0) or
	(level.map_has_object_spot(self:commander_id(), "ui_pda2_medic_location")~=0) then
		self.show_disabled = true
		return
	end

	if self.current_spot_id ~= self:commander_id() then
		self:hide()
		self.current_spot_id = self:commander_id()
		self:show()
		return
	end
	local spot = ""

	if not(is_squad_monster[self.player_id]) then
		local relation = game_relations.get_squad_relation_to_actor_by_id(self.id)
		if(relation=="friends") then
			spot = "alife_presentation_squad_friend"
		elseif(relation=="neutral") then
			spot = "alife_presentation_squad_neutral"
		end
	end

    if (dev_debug and not axr_main) or (axr_main and axr_main.config and axr_main.config:GetValue("debug","enable_hud",1,false) == true) then
		spot = "storyline_task_location"
	end
	if(spot~="") then
		if spot == self.spot_section then
			level.map_change_spot_hint(self.current_spot_id, self.spot_section, self:get_squad_props())
			return
		end
		if self.spot_section == nil then
			level.map_add_object_spot(self.current_spot_id, spot, self:get_squad_props())
		else
			level.map_remove_object_spot(self.current_spot_id, self.spot_section)
			level.map_add_object_spot(self.current_spot_id, spot, self:get_squad_props())
		end
		self.spot_section = spot
	elseif(self.spot_section~=nil) then
		level.map_remove_object_spot(self.current_spot_id, self.spot_section)
		self.spot_section = nil
	end
end

function sim_squad_scripted:get_squad_props()
	if dev_debug then
		local assigned_target = self.assigned_target_id and alife():object(self.assigned_target_id)
		local current_target = self.current_target_id and alife():object(self.current_target_id)

		local t = self.disabled and "disabled\\n\\n" or ""

		t = t .. "%s\\n\\n%s\\n\\n current_target=%s\\nassigned_target=%s\\n\\n"
		t = alun_utils.sr(t,self.disabled and "[disabled]" or "",self:name(),self.current_target_id == 0 and "actor" or current_target and current_target:name(),self.assigned_target_id == 0 and "actor" or assigned_target and assigned_target:name())

		if (self.current_action) then
			t = t .. tostring(self.current_action.name)
			if (self.current_action.name == "stay_point") then
				t = t .. " = " .. tostring(self.current_action.idle_time - game.get_game_time():diffSec(self.current_action.start_time))
			end
		end
		return t
	else
		return ""
	end
end




--***********************************************************************************************
--*										SIMULATION_TARGET_SQUAD									*
--***********************************************************************************************
function sim_squad_scripted:get_location()
	return self.position, self.m_level_vertex_id, self.m_game_vertex_id
end

local function get_current_task(squad)
	local smart = squad.assigned_target_id and alife():object(squad.assigned_target_id)
	if (smart) then
		if (smart.job_data and smart.arriving_npc and not smart.arriving_npc[squad:commander_id()]) then
			local npc_info = smart.npc_info and smart.npc_info[squad:commander_id()]
			if (npc_info and npc_info.job) then
				return npc_info.job.alife_task or smart:get_alife_task() or squad:get_alife_task()
			end
		end
		return smart:get_alife_task()
	end
	return squad:get_alife_task()
end 

-- called from engine
function sim_squad_scripted:get_current_task()
	return get_current_task(self)
end

function sim_squad_scripted:am_i_reached(squad)
	if (squad and self.id == squad.id) then
		return true
	end
	return squad.m_game_vertex_id == self.m_game_vertex_id or self:npc_count() == 0
end

function sim_squad_scripted:on_after_reach(squad)
	squad.current_action = nil
	squad.current_target_id = nil
end

function sim_squad_scripted:on_reach_target(squad)
	squad:set_location_types()
	-- Why is this done?
 	for k in squad:squad_members() do
		if db.offline_objects[k.id] ~= nil then
			db.offline_objects[k.id] = db.offline_objects[k.id] and empty_table(db.offline_objects[k.id])
		end
	end
	self.board:assign_squad_to_smart(squad, nil)
end

function sim_squad_scripted:get_alife_task()
	return CALifeSmartTerrainTask(self.m_game_vertex_id, self.m_level_vertex_id)
end

local smarts_by_no_assault_zones = {
									["zat_a2_sr_no_assault"] 	= "zat_stalker_base_smart",
									["jup_a6_sr_no_assault"] 	= "jup_a6",
									["jup_b41_sr_no_assault"] 	= "jup_b41"
}

function sim_squad_scripted:sim_available()

	--[[
	for k,v in pairs (smarts_by_no_assault_zones) do
		local zone = db.zone_by_name[k]
		if zone and zone:inside(self.position) then
			local smart = sim_board.get_sim_board():get_smart_by_name(v)
			if smart and smart.base_on_actor_control ~= nil and smart.base_on_actor_control.status ~= smart_terrain_control.ALARM then
				return false
			end
		end
	end
	--]]

	if self.smart_id == nil then
		return true
	end

	local smart = alife():object(self.smart_id)
	if not (smart) then
		return false
	end

	-- Can't be targetted by other squads if at base or trade prop smart
	if (smart.props) then
		if (smart.props["base"] and tonumber(smart.props["base"]) > 0) then
			return false
		end
	end

	if smart.base_on_actor_control ~= nil and smart.base_on_actor_control.status ~= smart_terrain_control.NORMAL then
		if db.zone_by_name[smart.base_on_actor_control.noweap_zone] == nil or not db.zone_by_name[smart.base_on_actor_control.noweap_zone]:inside(self.position) then
			return false
		end
	end
	return true
end

function sim_squad_scripted:target_precondition(squad)
	local squad_params = sim_board.simulation_activities[squad.player_id]
	if squad_params == nil or squad_params.squad == nil then
		return false
	end

	local self_params = squad_params.squad[self.player_id]
	if self_params == nil or self_params.prec(squad, self) == false then
		return false
	end
	return true
end

function sim_squad_scripted:evaluate_prior(squad)
	return simulation_objects.evaluate_prior(self, squad)
end
