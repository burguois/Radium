-- Callbacks are handled by axr_main
-- To keep everything modular, register for callbacks instead of editing script directly
-- This way, to disable your features, all someone has to do is comment a single line in axr_main.on_game_start
-- or even better, remove the *.script
-- alundaio

function init(obj)
	xr_motivator.AddToMotivator(obj)
end

function actor_init(npc)
	npc:bind_object(actor_binder(npc))
end
checker = 30
wpn_checker = 0
clinkcounter = 1
clinkswitch = true
----------------------------------------------------------------------------------------------------------------------
class "actor_binder" (object_binder)
----------------------------------------------------------------------------------------------------------------------
function actor_binder:__init (obj) super(obj)
	self.bCheckStart = false
	self.weather_manager = level_weathers.get_weather_manager()
	self.surge_manager = surge_manager.get_surge_manager()

	self.last_level_name = "nil"
	self.deimos_intensity = nil

	self.last_detective_achievement_spawn_time 	= nil
	self.last_mutant_hunter_achievement_spawn_time	= nil
	-- Alundaio
	axr_main.actor_on_init(self)
	-- End Alundaio
end

----------------------------------------------------------------------------------------------------------------------
function actor_binder:net_spawn(data)
	--printf("actor net spawn")
	level.show_indicators()
	self.bCheckStart = true
	self.weapon_hide = false -- спрятано или нет оружие при разговоре.
	self.weapon_hide_in_dialog = false

	if object_binder.net_spawn(self,data) == false then
		return false
	end
	db.add_actor(self.object)
	db.add_enemy(self.object)

	db.actor.deimos_intensity = self.deimos_intensity
	self.deimos_intensity = nil
	if self.st.disable_input_time == nil then
		level.enable_input()
	end

	self.weather_manager:reset()
	death_manager.init_drop_settings()
	self.task_manager = task_manager.get_task_manager()
	self.spawn_frame = device().frame
	self.already_jumped = false
	self.loaded = false

	-- alundaio
	axr_main.on_game_load()
	-- end alundaio

	return true
end
----------------------------------------------------------------------------------------------------------------------
function actor_binder:net_destroy()
	xr_sound.stop_sounds_by_id(self.object:id())
	local board_factions = SIMBOARD.players
	if(board_factions) then
		for k,v in pairs (board_factions) do
			xr_sound.stop_sounds_by_id(v.id)
		end
	end
	if(actor_stats.remove_from_ranking~=nil)then
		actor_stats.remove_from_ranking(self.object:id())
	end
	level.show_weapon(true)
	db.del_actor(self.object)
	db.delete_enemy(self.object)

	self.object:set_callback(callback.inventory_info, nil)
	self.object:set_callback(callback.on_item_take, nil)
	self.object:set_callback(callback.on_item_drop, nil)
	self.object:set_callback(callback.task_state, nil)
	self.object:set_callback(callback.level_border_enter, nil)
	self.object:set_callback(callback.level_border_exit, nil)
	self.object:set_callback(callback.take_item_from_box, nil)
	self.object:set_callback(callback.use_object, nil)
	self.object:set_callback(callback.hit, nil)
	if (callback.key_press) then
		self.object:set_callback(callback.key_press, nil)
	end

	if(_G.amb_vol~=0) then
		get_console():execute("snd_volume_eff "..tostring(_G.amb_vol))
		_G.amb_vol = 0
	end
	if(_G.mus_vol~=0) then
	    get_console():execute("snd_volume_music "..tostring(_G.mus_vol))
		_G.mus_vol = 0
	end
	if sr_psy_antenna.psy_antenna then
		sr_psy_antenna.psy_antenna:destroy()
		sr_psy_antenna.psy_antenna = false
	end

	-- Alundaio
	axr_main.on_game_end()
	-- Alundaio
	object_binder.net_destroy(self)
end
----------------------------------------------------------------------------------------------------------------------
function actor_binder:reinit()
	object_binder.reinit(self)
	local npc_id = self.object:id()
	db.storage[npc_id] = empty_table(db.storage[npc_id])
	self.st = db.storage[npc_id]

	self.object:set_callback(callback.task_state, self.task_callback, self)
	
	self.object:set_callback(callback.inventory_info, axr_main.actor_on_info_callback, self)
	self.object:set_callback(callback.on_item_take, axr_main.actor_on_item_take, self)
	self.object:set_callback(callback.on_item_drop, axr_main.actor_on_item_drop, self)
	self.object:set_callback(callback.trade_sell_buy_item, axr_main.actor_on_trade, self)
	self.object:set_callback(callback.take_item_from_box, axr_main.actor_on_item_take_from_box, self)
	self.object:set_callback(callback.use_object, axr_main.actor_on_item_use, self)
	self.object:set_callback(callback.hit, axr_main.actor_on_hit_callback, self)
	if (callback.key_press) then
		self.object:set_callback(callback.key_press, axr_main.key_press, self)
	end
end

function anabiotic_callback()
	level.add_cam_effector("camera_effects\\surge_01.anm", 10, false, "bind_stalker.anabiotic_callback2")
	local rnd = math.random(35,45)
	local m = surge_manager.get_surge_manager()
	if(m.started) then
		local tf = level.get_time_factor()
		local diff_sec = math.ceil(game.get_game_time():diffSec(m.inited_time)/tf)
			if(rnd>(m.surge_time-diff_sec)*tf/60) then
			m.time_forwarded = true
			m.ui_disabled = true
			m:kill_all_unhided()
			m:end_surge()
		end
	end
	m = psi_storm_manager and psi_storm_manager.get_psi_storm_manager()
	if(m and m.started) then
		local tf = level.get_time_factor()
		local diff_sec = math.ceil(game.get_game_time():diffSec(m.inited_time)/tf)
			if(rnd>(m.psi_storm_duration-diff_sec)*tf/60) then
			m.time_forwarded = true
			--m.ui_disabled = true
			m:finish()
		end
	end
	level.change_game_time(0,0,rnd)
	level_weathers.get_weather_manager():forced_weather_change()
	--printf("anabiotic_callback: time forwarded on [%d]", rnd)
end

function anabiotic_callback2()
	xr_effects.enable_ui(db.actor, nil)
    get_console():execute("snd_volume_music "..tostring(_G.mus_vol))
	get_console():execute("snd_volume_eff "..tostring(_G.amb_vol))
	_G.amb_vol = 0
	_G.mus_vol = 0
	disable_info("anabiotic_in_process")
end
----------------------------------------------------------------------------------------------------------------------

function actor_binder:task_callback(_task, _state)
	if _state ~= task.fail then
		if _state == task.completed then
			news_manager.send_task(db.actor, "complete", _task)
		else
			news_manager.send_task(db.actor, "new", _task)
		end
	end
	task_manager.task_callback(_task, _state)
end

----------------------------------------------------------------------------------------------------------------------

function actor_binder:update(delta)
	object_binder.update(self, delta)
	--alun_utils.debug_write("actor update START")
	--printf("actor update start")
	if not (db.actor:alive()) then
		return
	end
	
	if self.bCheckStart then -- first update after netspawn
		--printf("SET DEFAULT INFOS")
		if not has_alife_info("global_dialogs") then
			self.object:give_info_portion("global_dialogs")
		end
		if not has_alife_info("level_changer_icons") then
			self.object:give_info_portion("level_changer_icons")
		end
		pda.fill_primary_objects()
		self.object:activate_slot(3)
		self.bCheckStart = false
	end

	self.task_manager:update()

	-- DEBUG slowdown
	--slowdown.update()
	
	game_stats.update (delta, self.object)

	-- апдейт погоды
	self.weather_manager:update()

	self:check_detective_achievement()
	self:check_mutant_hunter_achievement()

	--' Апдейт саундменеджера
	xr_sound.update(self.object:id())

	-- Обновление отключения ввода с клавиатуры.
	if self.st.disable_input_time ~= nil and
		game.get_game_time():diffSec(self.st.disable_input_time) >= self.st.disable_input_idle
		then
		level.enable_input()
		self.st.disable_input_time = nil
	end

	-- Апдейт прятание оружия игрока во время диалога
	if self.object:is_talking() then
		if self.weapon_hide_in_dialog == false then
			self.object:hide_weapon()
			--printf("hiding weapon!!!")
			self.weapon_hide_in_dialog = true
		end
	else
		if self.weapon_hide_in_dialog == true then
			--printf("restoring weapon!!!")
			self.object:restore_weapon()
			self.weapon_hide_in_dialog = false
		end
	end

	-- обновление пси-антенны
	if sr_psy_antenna.psy_antenna then
		sr_psy_antenna.psy_antenna:update(delta)
	end

	if(self.surge_manager) then
		if(self.f_surge_manager_loaded ~= true) then
			self.surge_manager:initialize()
			self.f_surge_manager_loaded = true
		end
		if(self.surge_manager.levels_respawn[level.name()]) then
			self.surge_manager:respawn_artefacts_and_replace_anomaly_zone()
		end
		self.surge_manager:update()
	end

	-- Апдейт доступности для симуляции.
	simulation_objects.get_sim_obj_registry():update_avaliability(alife():actor())

	-- alundaio
	--printf("actor update before axr_main")
	axr_main.actor_on_update(self,delta)
	-- alundaio
	
	local tg = time_global()
	if (self.last_update and tg < self.last_update) then
		--printf("actor update end")
		return
	end
	self.last_update = tg + 3000

	pda.fill_sleep_zones()
	treasure_manager.get_treasure_manager():update()
  	--dynamic_gunfire.check_fire()	
	--printf("actor update end")
	--alun_utils.debug_write("actor update END")
end
----------------------------------------------------------------------------------------------------------------------
function actor_binder:save(packet)
	--alun_utils.debug_write("--------------- actor_binder:save -------- Start")
	set_save_marker(packet, "save", false, "actor_binder")
	object_binder.save(self, packet)
	--' Сохраняем уровень сложности

	--alundaio
	alun_utils.w_stpk(packet,"u8",level.get_game_difficulty(), "game difficulty")
	alun_utils.w_stpk(packet,"CTime",self.st.disable_input_time, "disable input time")

	xr_logic.pstor_save_all(self.object, packet)
	self.weather_manager:save(packet)
	release_body_manager.get_release_body_manager():save(packet)
	self.surge_manager:save(packet)
	sr_psy_antenna.save( packet )

	alun_utils.w_stpk(packet,"bool",SIMBOARD.simulation_started, "sim started")

	xr_sound.actor_save(packet)
	alun_utils.w_stpk(packet,"stringZ",self.last_level_name,"last level name")
	xr_statistic.save(packet)
	treasure_manager.get_treasure_manager():save(packet)
	task_manager.get_task_manager():save(packet)
	packet:w_u8(self.object:active_slot())

	local deimos_exist = false
	for k,v in pairs(db.zone_by_name) do
		if(db.storage[v:id()] and db.storage[v:id()].active_scheme=="sr_deimos") then
			deimos_exist = true
			packet:w_bool(true)
			alun_utils.w_stpk(packet,"float",db.storage[v:id()].sr_deimos.intensity, "deimos.intensity")
		end
	end
	if not deimos_exist then
		packet:w_bool(false)
	end

	if self.last_detective_achievement_spawn_time == nil then
		packet:w_bool(false)
	else
		packet:w_bool(true)
		alun_utils.w_stpk(packet,"CTime",self.last_detective_achievement_spawn_time, "detective spawn time")
	end

	if self.last_mutant_hunter_achievement_spawn_time == nil then
		packet:w_bool(false)
	else
		packet:w_bool(true)
		alun_utils.w_stpk(packet,"CTime",self.last_mutant_hunter_achievement_spawn_time, "hunter spawn time")
	end

	--alundaio
	axr_main.actor_on_save(self,packet)
	-- alundaio end
	set_save_marker(packet, "save", true, "actor_binder")
	--alun_utils.debug_write("--------------- actor_binder:save -------- End")
end

----------------------------------------------------------------------------------------------------------------------
function actor_binder:load(reader)
	set_save_marker(reader, "load", false, "actor_binder")
	object_binder.load(self, reader)

	local game_difficulty_by_num = {
				[0] = "gd_novice",
				[1] = "gd_stalker",
				[2] = "gd_veteran",
				[3] = "gd_master"
				}
	local dif = game_difficulty_by_num[reader:r_u8()]
	if not (dif) then
		set_save_marker(reader, "load", true, "actor_binder")
		return 
	end
	get_console():execute("g_game_difficulty "..dif)
	self.st.disable_input_time = utils.r_CTime(reader,"bind_stalker")

	xr_logic.pstor_load_all(self.object, reader)
	self.weather_manager:load(reader)
	release_body_manager.get_release_body_manager():load(reader)
	self.surge_manager:load(reader)
	self.f_surge_manager_loaded = true
	sr_psy_antenna.load(reader)
	SIMBOARD.simulation_started = reader:r_bool()

	xr_sound.actor_load(reader)
	local n = reader:r_stringZ()
	if(n~="nil") then
		self.last_level_name = n
	end
	xr_statistic.load(reader)
	treasure_manager.get_treasure_manager():load(reader)
	task_manager.get_task_manager():load(reader)

	self.loaded_active_slot = reader:r_u8()

	self.loaded_slot_applied = false

	local b = reader:r_bool()
	if(b) then
		self.deimos_intensity = reader:r_float()
	end

	local stored_achievement_time = reader:r_bool()
	if stored_achievement_time == true then
		self.last_detective_achievement_spawn_time = utils.r_CTime(reader,"bind_stalker")
	end
	stored_achievement_time = reader:r_bool()
	if stored_achievement_time == true then
		self.last_mutant_hunter_achievement_spawn_time = utils.r_CTime(reader,"bind_stalker")
	end
	--alundaio
	axr_main.actor_on_load(self,reader)
	-- end alundaio
	set_save_marker(reader, "load", true, "actor_binder")
end
--*************************************************************
--*					Подспаун вещей в ящики					  *
--*************************************************************
local detective_achievement_items 		= {	"medkit",
											"antirad",
											"bandage"}

local mutant_hunter_achievement_items	= {	"ammo_5.45x39_ap",
											"ammo_5.56x45_ap",
											"ammo_9x39_ap",
											"ammo_5.56x45_ap",
											"ammo_12x76_zhekan"}

local function spawn_achivement_items(items_table, count, inv_box_story_id)
	local inv_box = alife():object(get_story_object_id(inv_box_story_id))
	for i = 1,count do
		alife():create(items_table[math.random(#items_table)],
						inv_box.position,
						inv_box.m_level_vertex_id,
						inv_box.m_game_vertex_id,
						inv_box.id)
	end
end

function actor_binder:check_detective_achievement()
	if not has_alife_info("detective_achievement_gained") then
		return
	end
	if self.last_detective_achievement_spawn_time == nil then
		self.last_detective_achievement_spawn_time = game.get_game_time()
	end
	if game.get_game_time():diffSec(self.last_detective_achievement_spawn_time) > 43200 then
		spawn_achivement_items(detective_achievement_items, 4, "zat_a2_actor_treasure")
		xr_effects.send_tip(db.actor, nil, {"st_detective_news","got_medicine"})
		self.last_detective_achievement_spawn_time = game.get_game_time()
	end
end

function actor_binder:check_mutant_hunter_achievement()
	if not has_alife_info("mutant_hunter_achievement_gained") then
		return
	end
	if self.last_mutant_hunter_achievement_spawn_time == nil then
		self.last_mutant_hunter_achievement_spawn_time = game.get_game_time()
	end
	if game.get_game_time():diffSec(self.last_mutant_hunter_achievement_spawn_time) > 43200 then
		spawn_achivement_items(mutant_hunter_achievement_items, 5, "jup_b202_actor_treasure")
		xr_effects.send_tip(db.actor, nil, {"st_mutant_hunter_news","got_ammo"})
		self.last_mutant_hunter_achievement_spawn_time = game.get_game_time()
	end

end

----------------------------------------------------------------------------------------------------------------------

function check_for_weapon_hide_by_zones()
	for k,v in pairs(weapon_hide) do
		if v == true then
			return true
		end
	end
	return false
end

-- Weapon functions
function hide_weapon(zone_id)
	printf("[WEAPON_CONTROL]:hiding weapon from zone [%s] in section [%s]!!!", zone_id, db.storage[zone_id].active_section)
	weapon_hide[zone_id] = true
end

function restore_weapon(zone_id)
	printf("[WEAPON_CONTROL]:restoring weapon from zone [%s] in section [%s]!!!", zone_id, db.storage[zone_id].active_section)
	weapon_hide[zone_id] = false
end

