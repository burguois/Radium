--[[
Copyright (C) 2012-2015 Alundaio
This work is licensed under a Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License

Callback and module manager for easy plug-in based script management
by Alundaio

TODO: Split up some features into their own scripts, such as event queue, sound_threshold check and marshal 
also consider moving MAX_SQUADS to sim_squad_scripted.script
--]]

require("lua_extensions")
marshal = require "marshal"

local alife, game_graph, pairs, level = alife, game_graph, pairs, level
local last_save

-------------------------------------------------------------------------------------------------
-- Use marshal library for saving persistent data (like xr_logic pstor)
-- marshal library can encode tables, functions, strings and numbers to easily allow persistent data storage to file
-- This is used for db.storage[id].pstor and coc_treasure_manager.script if enabled

USE_MARSHAL = false --marshal ~= nil
m_data = {}
-------------------------------------------------------------------------------------------------

REMOVE_ME_LC			= nil 			-- Used by custom jump level command in xrs_debug_tools and faction select
------------------------------
LOUD_SOUND_THRESHOLD 	= 35			-- Used for actor targetting by sim_board.script
MAX_SQUADS 				= 256			-- Non-storied Squads above this count will randomly be removed on game load
------------------------------

config = alun_utils.cfg_file(alun_utils.fspath("$game_data$").."axr_options.ini")

-- Valid Callbacks (named intercepts to avoid namespace conflicts)
-- 
-- You must register a callback before or during on_game_load (ie. bind_actor net_spawn)
-- All unused callbacks will have their table deleted from intercepts (see on_game_load for implementation)
local intercepts = {
	-- _g.script

	-- ui_main_menu.script
	main_menu_on_keyboard		= {},
	main_menu_on_init			= {},
	main_menu_on_init_callbacks	= {},
	main_menu_on_quit			= {},

	-- ui_mm_opt_main.script
	opt_menu_on_init			= {},
	opt_menu_on_accept			= {},
	opt_menu_on_set_values		= {},

	-- xr_motivator.script
	npc_on_use 					= {},
	npc_on_item_take 			= {},
	npc_on_item_drop 			= {},
	npc_on_net_spawn			= {},
	npc_on_net_destroy 			= {},
	npc_on_update				= {},
	npc_on_weapon_no_ammo 		= {},
	npc_on_weapon_sight			= {},
	npc_on_weapon_unsight		= {},
	npc_on_hit_callback			= {},
	npc_on_death_callback		= {},
	npc_on_fighting_actor		= {},
	npc_add_precondition		= {},
	npc_on_item_take_from_box	= {},
	npc_on_weapon_state_change	= {},

	-- state_mgr_weapon.script
	npc_on_weapon_strapped		= {},
	npc_on_weapon_unstrapped	= {},
	npc_on_weapon_drop			= {},

	-- xr_hear.script
	npc_on_hear_callback		= {},

	-- se_stalker.script
	se_stalker_on_spawn			= {},

	-- se_actor.script
	se_actor_on_register		= {},
	se_actor_on_unregister		= {},
	se_actor_on_STATE_Write		= {},
	se_actor_on_STATE_Read		= {},

	-- xr_corpse_detection.script
	npc_on_get_all_from_corpse 	= {},

	-- sim_board.script
	squad_on_update				= {},
	squad_on_npc_creation		= {},
	squad_on_add_npc			= {},
	squad_can_switch_offline	= {},
	squad_on_unregister			= {},

	-- sim_squad_scripted.script
	squad_assign_new_target		= {},
	squad_can_help_actor		= {},
	squad_on_npc_death			= {},

	-- xr_logic.script
	on_pstor_load_all			= {},
	--set_generic_scheme			= {},
	--scheme_reset				= {},
	--scheme_disable				= {},
	--scheme_deactivate			= {},

	-- bind_stalker.script
	on_game_load				= {},
	on_game_end					= {},
	actor_on_update				= {},
	actor_on_weapon_no_ammo		= {},
	actor_on_weapon_zoom_in		= {},
	actor_on_weapon_zoom_out	= {},
	actor_on_item_take			= {},
	actor_on_item_take_from_box = {},
	actor_on_item_drop			= {},
	actor_on_item_use			= {},
	actor_on_trade				= {},
	actor_on_save				= {},
	actor_on_load				= {},
	actor_on_init				= {},
	actor_on_torch_enabled		= {},
	actor_on_torch_disabled		= {},
	actor_on_info_callback		= {},
	actor_on_leave_dialog		= {},
	actor_on_hit_callback		= {},

	-- bind_monster.script
	monster_on_update				= {},
	monster_on_hit_callback			= {},
	monster_on_net_spawn			= {},
	monster_on_death_callback		= {},
	monster_on_actor_use_callback   = {},

	-- bind_physic_object
	physic_object_on_hit_callback 	= {},
	physic_object_on_use_callback 	= {},

	-- axr_main (custom)
	on_level_changing				= {},
	
	-- Custom saving feature (uses Xetril's lua.jit dll)
	save_state						= {},
	load_state						= {}
}

-----------------------------------------------------------
-- Global Callback Register
-- param 1 - name as type<string> (ie. intercepts[name])
-- param 2 - function to execute as type<function> or type<table>
-----------------------------------------------------------
function callback_register(name,func)
	if not (func) then
		return
	end
	if (intercepts[name]) then
		table.insert(intercepts[name],func)
	end
end

function callback_unregister(name,func)
	if not (intercepts[name]) then
		return
	end

	local index
	for i=#intercepts[name],1,-1 do
		if (intercepts[name][i] == func) then
			index = i
			break
		end
	end

	if (index) then
		table.remove(intercepts[name],index)
	end
end

--------------------------------------------
-- Displays message on middle-top of screen for n amount of milliseconds
-- param 1 - Message as string
-- param 2 - Milliseconds as number
--------------------------------------------
local ShowMessageTime
function _G.SetHudMsg(msg,n)
	msg = tostring(msg)
	local hud = get_hud()
	hud:AddCustomStatic("not_enough_money_mine", true)
	hud:GetCustomStatic("not_enough_money_mine"):wnd():TextControl():SetTextST(msg)
	ShowMessageTime = time_global() + n*1000
end

--------------------------------------------------------------------------------------------
-- 								Delayed Event Queue
--
-- Events must have a unique id. Such as object id or another identifier unique to the occasion.
-- Action id must be unique to the specific Event. This allows a single event to have many queued
-- actions waiting to happen.
--
-- Returning true will remove the queued action. Returning false will execute the action continuously.
-- This allows for events to wait for a specific occurrence, such as triggering after a certain amount of
-- time only when object is offline
--
-- param 1 - Event ID as type<any>
-- param 2 - Action ID as type<any>
-- param 3 - Timer in seconds as type<number>
-- param 4 - Function to execute as type<function>
-- extra params are passed to executing function as table as param 1

-- see on_game_load or state_mgr_animation.script for example uses
-- All queued actions are executed on game save. If using marshal, then queue persists through saves
----------------------------------------------------------------------------------------------
local ev_queue = {}
function _G.create_delayed_event(ev_id,act_id,timer,f,...)
	if not (ev_queue[ev_id]) then
		ev_queue[ev_id] = {}
		ev_queue[ev_id].size = 0
	end

	if not (ev_queue[ev_id][act_id]) then
		ev_queue[ev_id][act_id] = {}
		ev_queue[ev_id][act_id].game_time = game.get_game_time()
		ev_queue[ev_id][act_id].timer = timer
		ev_queue[ev_id][act_id].f = f
		ev_queue[ev_id][act_id].p = {...}
		ev_queue[ev_id].size = ev_queue[ev_id].size + 1
	end
end

--------------------------------------------------------------------------------------------------------------------
-- Private functions
--------------------------------------------------------------------------------------------------------------------
local function remove_squad(p)
	local squad = p[1] and alife():object(p[1])
	if not (squad) then
		return true
	end

	if squad.current_action == nil or squad.current_action.dest_smrt == nil then
		squad.board:exit_smart(squad, squad.smart_id)
	end

	squad.board:assign_squad_to_smart(squad, nil)
	squad:remove_squad()
	return true
end

local function remove_non_story_squads(p)
	local sor = story_objects.get_story_objects_registry()
	local board = SIMBOARD
	local gg = game_graph()
	local se_actor = alife():actor()
	
	for id,squad in pairs(board.squads) do
		if (squad and squad.m_game_vertex_id and sor:get_story_id(id) == nil) then
			-- simulation_objects.sim_dist_to(se_actor,squad) > 2000
			if (gg:vertex(db.actor:game_vertex_id()):level_id() ~= gg:vertex(squad.m_game_vertex_id):level_id()) then
				create_delayed_event(squad.id,"remove_squad",math.random(1,220),remove_squad,squad.id)
				p[1] = p[1] - 1
			end
		end

		if (p[1] < MAX_SQUADS) then
			return true
		end
	end
	return true
end

local function event_queue(force)
	local gt
	for event_id,actions in pairs(ev_queue) do

		for action_id,act in pairs(actions) do
			--alun_utils.debug_write(alun_utils.sr("event_queue: event_id=%s action_id=%s",event_id,action_id))
			if (action_id ~= "size") then
				gt = act.game_time
				if (gt == nil) or (force) or (game.get_game_time():diffSec(gt) >= act.timer) then
					if (act.f(act.p) == true) then
						ev_queue[event_id][action_id] = nil
						ev_queue[event_id].size = ev_queue[event_id].size - 1
					end
				end
			end
		end

		if (ev_queue[event_id].size == 0) then
			ev_queue[event_id] = nil
		end
	end
end

--[[
									ON GAME START

	Register modules here. Their on_game_start functions should register callbacks they need.
	
--]]
function on_game_start()

	modules.on_game_start()
	
	if (xrs_debug_tools) then xrs_debug_tools.on_game_start() end
	-- CoP
	if (xrs_dyn_music) then xrs_dyn_music.on_game_start() end 
	
	-- Call of Chernobyl specific
	if (coc_treasure_manager) then coc_treasure_manager.on_game_start() end
	
	-- Radium
	if (axr_radium) then axr_radium.on_game_start() end
	if (axr_surge) then axr_surge.on_game_start() end

	-- Atmosfear
	if (atmosfear) then atmosfear.on_game_start() end

	-- Alundaio Extensions
	if (xrs_rnd_npc_loadout) then xrs_rnd_npc_loadout.on_game_start() end
	if (axr_dynamic_spawn) then axr_dynamic_spawn.on_game_start() end
	if (itms_manager) then itms_manager.on_game_start() end
	if (xr_statistic.on_game_start) then xr_statistic.on_game_start() end
	if (m_mines) then m_mines.on_game_start() end

	-- AI Tweaks
	if (ai_tweaks) then ai_tweaks.on_game_start() end
	if (axr_companions) then axr_companions.on_game_start() end
	--if (xr_visual) then xr_visual.on_game_start() end
	if (xr_eat_medkit) then xr_eat_medkit.on_game_start() end
	if (axr_trade_manager) then axr_trade_manager.on_game_start() end
end

-------------------
-- se_actor_on_register()
-- Notes: This runs soon after alife simulator is started.
-------------------
function se_actor_on_register(actor)
	--alun_utils.debug_write("se_actor_on_register")
	if (intercepts.se_actor_on_register) then
		for i=1, #intercepts.se_actor_on_register do
			intercepts.se_actor_on_register[i](actor)
		end
	end
end

-------------------
-- se_actor_on_unregister()
-------------------
function se_actor_on_unregister(actor)
	--alun_utils.debug_write("se_actor_on_unregister")
	if (intercepts.se_actor_on_unregister) then
		for i=1, #intercepts.se_actor_on_unregister do
			intercepts.se_actor_on_unregister[i](actor)
		end
	end
end

-------------------
-- se_actor_on_STATE_Write(se_actor,packet)
-------------------
function se_actor_on_STATE_Write(se_actor,packet)
	--alun_utils.debug_write("se_actor_on_STATE_Write")
end

-------------------
-- se_actor_on_STATE_Read(se_actor,packet)
-------------------
function se_actor_on_STATE_Read(se_actor,packet,size)
	--alun_utils.debug_write("se_actor_on_STATE_Read")
end

-------------------
-- on_game_load() ;Actor Net Spawn
-------------------
function on_game_load()
	math.randomseed(time_global())
	
	--alun_utils.debug_write("on_game_load")
	for i=1, #intercepts.on_game_load do
		intercepts.on_game_load[i]()
	end

	local count = 0
	local sor = story_objects.get_story_objects_registry()
	local board = SIMBOARD
	local gg = game_graph()
	for id,squad in pairs(board.squads) do
		if (squad and squad.m_game_vertex_id and sor:get_story_id(id) == nil) then
			if (gg:vertex(db.actor:game_vertex_id()):level_id() ~= gg:vertex(squad.m_game_vertex_id):level_id()) then
				count = count + 1
			end
		end
	end

	-- Every game load we want to make sure there are no more then MAX_SQUADS existing for stability purposes
	if (count > MAX_SQUADS) then
		create_delayed_event(0,"remove_non_story_squads",60,remove_non_story_squads,count)
	end
	
	--[[
	count = 0
	local sim = alife()
	for i=1,65534 do
		if (sim:object(i)) then
			count = count + 1
		end
	end
	printf("axr_main.on_game_load: There are %s object ids in use.",count)
	--]]

	-- clean up intercepts table if callbacks are unused
	-- if needed this can be removed so that callbacks can be registered any time, not just before or during on_game_load
	for i=1,#intercepts do 
		if (#intercepts[i] == 0) then 
			intercepts[i] = nil
		end
	end
end

-------------------
-- on_game_end() ;Actor Net Destroy
-------------------
function on_game_end()
	--alun_utils.debug_write("on_game_end")
	if (intercepts.on_game_end) then
		for i=1, #intercepts.on_game_end do
			intercepts.on_game_end[i]()
		end
	end
end

---------------------
-- on_pstor_load_all(obj,packet)
---------------------
function on_pstor_load_all(obj,packet)
	--alun_utils.debug_write("on_pstor_load_all")
	if (intercepts.on_pstor_load_all) then
		for i=1, #intercepts.on_pstor_load_all do
			intercepts.on_pstor_load_all[i](obj,packet)
		end
	end
end

-------------------
-- actor_on_init()
-------------------
function actor_on_init(se_actor)
	--alun_utils.debug_write("actor_on_init")
	if (intercepts.actor_on_init) then
		for i=1, #intercepts.actor_on_init do
			intercepts.actor_on_init[i](se_actor)
		end
	end
end

-------------------
-- actor_on_info_callback(npc,info_id)
-------------------
function actor_on_info_callback(binder,npc,info_id)
	--alun_utils.debug_write("actor_on_info_callback "..tostring(info_id))
	if (intercepts.actor_on_info_callback) then
		for i=1, #intercepts.actor_on_info_callback do
			intercepts.actor_on_info_callback[i](npc,info_id)
		end
	end
end

-------------------
-- actor_on_update()
-------------------
local actor_sound_incr
local actor_reload
local actor_scope
local actor_talking
actor_light = nil
function actor_on_update(se_actor,delta)
	--alun_utils.debug_write("actor_on_update")
	local _aupdate = intercepts.actor_on_update
	if (_aupdate) then
		for i=1, #_aupdate do
			if (_aupdate[i]) then
				_aupdate[i](se_actor,delta)
			end
		end
	end

	local tg = time_global()
	
	-- evaluate event queue
	event_queue()

	-- Check HudMsg
	if (ShowMessageTime) then
		local hud = get_hud()
		local custom_static = hud:GetCustomStatic("not_enough_money_mine")
		if custom_static ~= nil and tg > ShowMessageTime then
			hud:RemoveCustomStatic("not_enough_money_mine")
			ShowMessageTime = nil
		end
	end

	if not upd_dtimer then
		upd_dtimer = tg + 250
	end

	if (tg < upd_dtimer) then
		return
	end
	upd_dtimer = tg + 250

	if (intercepts.actor_on_leave_dialog) then
		if (db.actor:is_talking() and not actor_talking) then 
			actor_talking = true
		elseif (db.actor:is_talking() ~= true and actor_talking) then 
			actor_talking = nil
			for i=1, #intercepts.actor_on_leave_dialog do
				intercepts.actor_on_leave_dialog[i](se_actor)
			end
		end
	end
	
	-- Are-wide sound decrement
	-- comment block this routine if need to optimize
	actor_sound_incr = actor_sound_incr and actor_sound_incr - 0.25
	if (actor_sound_incr and actor_sound_incr < 0) then
		actor_sound_incr = 0
	end

	if (db.storage[0].loud and tg > db.storage[0].loud) then
		db.storage[0].loud = nil
		db.storage[0].loud_gvid = nil
		db.storage[0].loud_lvid = nil
		--if (actor_sound_incr and actor_sound_incr < LOUD_SOUND_THRESHOLD) then
			--printf("Actor is quiet")
		--end
	end

	local wpn = db.actor:active_item()
	if (wpn) then
		local firearm = alun_utils.item_is_fa(wpn)
		if (firearm) then
		
			if (intercepts.actor_on_weapon_no_ammo) then
				local inmag = wpn:get_ammo_in_magazine()
				if (inmag == 0) then
					if not (actor_reload) then
						actor_reload = true
						actor_on_weapon_no_ammo(wpn)
					end
				else
					actor_reload = nil
				end
			end

			-- Area-wide sound threshold (Check sim_board how it's used)
			-- comment block this routine if need to optimize
			local se_obj = alife():object(wpn:id())
			local data = se_obj and stpk_utils.get_weapon_data(se_obj)
			if (data and data.weapon_state == 5) then

				if (alun_utils.addon_attached(wpn,"sl",data.addon_flags)) then
					actor_sound_incr = actor_sound_incr and actor_sound_incr + 1 or 1
				else
					actor_sound_incr = actor_sound_incr and actor_sound_incr + 2 or 2
				end

				if (actor_sound_incr > LOUD_SOUND_THRESHOLD) then
					actor_sound_incr = LOUD_SOUND_THRESHOLD
					--if not (db.storage[0].loud) then
						--printf("Actor is being loud")
					--end
					db.storage[0].loud = tg + 50000		-- 50 seconds
					db.storage[0].loud_gvid = db.actor:game_vertex_id()
					db.storage[0].loud_lvid = db.actor:level_vertex_id()
				end
			end
		end

		if (intercepts.actor_on_weapon_zoom_in) then
			if (wpn:section() == "wpn_binoc" or (firearm and alun_utils.addon_attached(wpn,"sc"))) then
				if (device().fov < 50) then
					if not (actor_scope) then
						actor_scope = true
						actor_on_weapon_zoom_in(wpn)
					end
				else
					if (actor_scope) then
						actor_scope = nil
						actor_on_weapon_zoom_out(wpn)
					end
				end
			else
				if (actor_scope) then
					actor_scope = nil
					actor_on_weapon_zoom_out(wpn)
				end
			end
		end
	end

	if (intercepts.actor_on_torch_enabled) then
		local torch = db.actor:object("device_torch")
		if (torch and not actor_light and torch:torch_enabled()) then
			actor_light = true
			actor_on_torch_enabled()
		elseif (torch and not torch:torch_enabled()) then
			if (actor_light) then
				actor_light = false
				actor_on_torch_disabled()
			end
		end
	end
end

-------------------
-- actor_on_weapon_no_ammo(wpn)
-------------------
function actor_on_weapon_no_ammo(wpn)
	for i=1, #intercepts.actor_on_weapon_no_ammo do
		intercepts.actor_on_weapon_no_ammo[i](wpn)
	end
end

-------------------
-- actor_on_weapon_zoom_in(wpn)
-------------------
function actor_on_weapon_zoom_in(wpn)
	for i=1, #intercepts.actor_on_weapon_zoom_in do
		intercepts.actor_on_weapon_zoom_in[i](wpn)
	end
end

-------------------
-- actor_on_weapon_zoom_out(wpn)
-------------------
function actor_on_weapon_zoom_out(wpn)
	for i=1, #intercepts.actor_on_weapon_zoom_out do
		intercepts.actor_on_weapon_zoom_out[i](wpn)
	end
end

-------------------
-- actor_on_torch_enabled()
-------------------
function actor_on_torch_enabled()
	for i=1, #intercepts.actor_on_torch_enabled do
		intercepts.actor_on_torch_enabled[i]()
	end
end

-------------------
-- actor_on_torch_disabled()
-------------------
function actor_on_torch_disabled()
	for i=1, #intercepts.actor_on_torch_disabled do
		intercepts.actor_on_torch_disabled[i]()
	end
end

-------------------
-- actor_on_item_take(item)
-------------------
function actor_on_item_take(binder,item)
	if IsArtefact(item) then
		local anomal_zone = bind_anomaly_zone.parent_zones_by_artefact_id[item:id()]
		if anomal_zone ~= nil then
			anomal_zone:on_artefact_take(item)
		else
			bind_anomaly_zone.artefact_ways_by_id[item:id()] = nil
		end
		local artefact = item:get_artefact()
		artefact:FollowByPath("NULL",0,vector():set(500,500,500))
		xr_statistic.inc_founded_artefacts_counter(item:id())
	end
	treasure_manager.get_treasure_manager():on_item_take(item:id())
	
	if (intercepts.actor_on_item_take) then
		for i=1, #intercepts.actor_on_item_take do
			intercepts.actor_on_item_take[i](item)
		end
	end
end

-------------------
-- actor_on_item_take_from_box(box,item)
-------------------
function actor_on_item_take_from_box(binder,box,item)
	if (intercepts.actor_on_item_take_from_box) then
		for i=1, #intercepts.actor_on_item_take_from_box do
			intercepts.actor_on_item_take_from_box[i](box,item)
		end
	end
end

-------------------
-- actor_on_item_drop(item)
-------------------
function actor_on_item_drop(binder,item)
	if (intercepts.actor_on_item_drop) then
		for i=1, #intercepts.actor_on_item_drop do
			intercepts.actor_on_item_drop[i](item)
		end
	end
end

-------------------
-- actor_on_item_use(item)
-------------------
function actor_on_item_use(binder,item)
	local sec = item:section()
	if (sec == "drug_anabiotic") then 
		xr_effects.disable_ui_only(db.actor, nil)
		level.add_cam_effector("camera_effects\\surge_02.anm", 10, false, "bind_stalker.anabiotic_callback")
		level.add_pp_effector("surge_fade.ppe", 11, false)
		give_info("anabiotic_in_process")
		local con = get_console()
		_G.mus_vol = con:get_float("snd_volume_music")
		_G.amb_vol = con:get_float("snd_volume_eff")
		con:execute("snd_volume_music 0")
		con:execute("snd_volume_eff 0")
	elseif (atmosfear) and (sec == "drug_psy_blockade" or sec == "drug_radioprotector" or sec == "drug_antidot") then
		local boost_time = system_ini():r_float(sec,"boost_time")
		xr_logic.pstor_store(db.actor,sec.."_expiration",atmosfear.CTimeAddSec(game.get_game_time(),boost_time*level.get_time_factor()))
	end 
	
	if (intercepts.actor_on_item_use) then
		for i=1, #intercepts.actor_on_item_use do
			intercepts.actor_on_item_use[i](item,sec)
		end
	end
end

-------------------
-- actor_on_trade(item)
-------------------
function actor_on_trade(binder,item,sell_bye,money)
	if sell_bye == true then
		 game_stats.money_trade_update (money)
	else
		 game_stats.money_trade_update (-money)
	end
	if (intercepts.actor_on_trade) then
		for i=1, #intercepts.actor_on_trade do
			intercepts.actor_on_trade[i](item,sell_bye,money)
		end
	end
end

-------------------
-- actor_on_save(bind_stalker,packet)
-------------------
function actor_on_save(binder,packet)

	if (intercepts.on_level_changing) then
		local sim,gg = alife(),game_graph()
		local actor_gv = sim and gg:vertex(sim:actor().m_game_vertex_id)
		
		if (actor_gv and actor_gv:level_id() ~= sim:level_id()) then
			--printf("actor changing level")
			if (REMOVE_ME_LC) then
				local sim = alife()
				local se_obj = sim:object(REMOVE_ME_LC)
				if (se_obj) then
					--printf("removing temp level_changer %s",se_obj:name())
					sim:release(se_obj,true)
				end
			end
			
			for i=1,#intercepts.on_level_changing do 
				intercepts.on_level_changing[i]()
			end
		end
	end

	if (USE_MARSHAL) then

		local path = alun_utils.fspath("$game_saves$")..(last_save or alun_utils.is_level_changing() and user_name():lower() .. " - autosave" or user_name():lower().." - quicksave")..".dat"
		last_save = nil

		local savegame = io.open(path,"wb+")
		if (savegame) then
		packet:w_stringZ(path)

			if (intercepts.save_state) then
				for i=1, #intercepts.save_state do
					intercepts.save_state[i](m_data)
				end
			end

			for id,t in pairs(db.storage) do
				if (t and type(t) == "table") then
					if (t.pstor) then
						if not (m_data.pstor_all) then
							m_data.pstor_all = {}
						end
						m_data.pstor_all[id] = t.pstor
					end
				end
			end

			local data = marshal.encode(m_data)
			if (data) then
				printf("axr_main: saving custom data %s",path)
				savegame:write(data)
				savegame:close()
			end
		end
		return
	end
	if (coc_treasure_manager) then
		coc_treasure_manager.save(packet)
	end
	if (atmosfear) then 
		atmosfear.actor_on_save(binder,packet) 
	end
	if (axr_dynamic_spawn) then
		axr_dynamic_spawn.actor_on_save(binder,packet)
	end
end

-------------------
-- actor_on_load(bind_stalker,packet)
-------------------
function actor_on_load(binder,packet)
	if (USE_MARSHAL) then
		local path = packet:r_stringZ()
		if (not path or path:sub(-4) ~= ".dat") then
			return
		end

		local savegame = io.open(path,"rb")
		if not (savegame) then
			return
		end

		local data = savegame:read("*all")
		savegame:close()

		if not (data) then
			return
		end

		m_data = marshal.decode(data) or m_data

		printf("axr_main: loading custom data %s", path)

		if (intercepts.load_state) then
			for i=1, #intercepts.load_state do
				intercepts.load_state[i](m_data)
			end
		end

		return
	end
	if (coc_treasure_manager) then
		coc_treasure_manager.load(packet)
	end
	if (atmosfear) then 
		atmosfear.actor_on_load(binder,packet) 
	end
	if (axr_dynamic_spawn) then
		axr_dynamic_spawn.actor_on_load(binder,packet)
	end
end

-------------------
-- actor_on_hit_callback(npc,amount,local_direction,who,bone_index)
-------------------
function actor_on_hit_callback(binder,npc,amount,local_direction,who,bone_index)
	if (amount <= 0) then
		return
	end
	--alun_utils.debug_write("npc_on_hit_callback")
	if (intercepts.actor_on_hit_callback) then
		for i=1, #intercepts.actor_on_hit_callback do
			intercepts.actor_on_hit_callback[i](npc,amount,local_direction,who,bone_index)
		end
	end
end

-------------------
-- se_stalker_on_spawn(se_npc)
-------------------
function se_stalker_on_spawn(se_npc)
	--alun_utils.debug_write("se_stalker_on_spawn"..tostring(se_npc and se_npc:name()))
	if (intercepts.se_stalker_on_spawn) then
		for i=1, #intercepts.se_stalker_on_spawn do
			intercepts.se_stalker_on_spawn[i](se_npc)
		end
	end
end

-------------------
-- npc_on_use(npc,who)
-------------------
function npc_on_use(npc,who)
	if (intercepts.npc_on_use) then
		for i=1, #intercepts.npc_on_use do
			intercepts.npc_on_use[i](npc,who)
		end
	end
end

-------------------
-- npc_on_item_take(npc,item)
-------------------
function npc_on_item_take(npc,item)
	--alun_utils.debug_write("npc_on_item_take")
	if (intercepts.npc_on_item_take) then
		for i=1, #intercepts.npc_on_item_take do
			intercepts.npc_on_item_take[i](npc,item)
		end
	end
end

-------------------
-- npc_on_item_drop(npc,item)
-------------------
function npc_on_item_drop(npc,item)
	--alun_utils.debug_write("npc_on_item_drop")
	if (intercepts.npc_on_item_drop) then
		for i=1, #intercepts.npc_on_item_drop do
			intercepts.npc_on_item_drop[i](npc,item)
		end
	end
end

-------------------
-- npc_on_net_spawn(npc,se_npc)
-------------------
function npc_on_net_spawn(npc,se_npc)
	--alun_utils.debug_write("npc_on_net_spawn")
	if (intercepts.npc_on_net_spawn) then
		for i=1, #intercepts.npc_on_net_spawn do
			intercepts.npc_on_net_spawn[i](npc,se_npc)
		end
	end
end

-------------------
-- npc_on_net_destroy(npc)
-------------------
function npc_on_net_destroy(npc)
	--alun_utils.debug_write("npc_on_net_destroy")
	if (intercepts.npc_on_net_destroy) then
		for i=1, #intercepts.npc_on_net_destroy do
			intercepts.npc_on_net_destroy[i](npc)
		end
	end
end

-------------------
-- npc_on_update(npc,st)
-------------------
function npc_on_update(npc,st)
	--alun_utils.debug_write("npc_on_update %s",npc:name())
	local _nupdate = intercepts.npc_on_update
	if (_nupdate) then
		for i=1, #_nupdate do
			--alun_utils.debug_write("npc_on_update %s BEFORE iterate",npc:name())
			_nupdate[i](npc,st)
			--alun_utils.debug_write("npc_on_update %s AFTER iterate",npc:name())
		end
	end

	if not (npc:alive()) then
		return 
	end 
	
	local wpn = npc:best_weapon()
	if (wpn and alun_utils.item_is_fa(wpn)) then
	
		if (intercepts.npc_on_weapon_no_ammo) then
			local inmag = wpn:get_ammo_in_magazine()
			if (inmag == 0) then
				if not (st.weapon_reload) then
					st.weapon_reload = true
					npc_on_weapon_no_ammo(npc,wpn,st)
				end
			else
				st.weapon_reload = nil
			end
		end

		if (intercepts.npc_on_weapon_sight) then
			local sight_type = npc:sight_params().m_sight_type
			if (sight_type) and (sight_type == 4 or sight_type == 9 or sight_type == 10) then
				if not (st.sight_type) then
					npc_on_weapon_sight(npc,wpn,st,sight_type)
					st.sight_type = sight_type
				end
			else
				if (st.sight_type) then
					st.sight_type = nil
					npc_on_weapon_unsight(npc,wpn,st,sight_type)
				end
			end
		end

		if (intercepts.npc_on_weapon_state_change) then
			local sobj = alife():object(wpn:id())
			local data = stpk_utils.get_weapon_data(sobj)

			if (data and st.weapon_state ~= data.weapon_state) then
				npc_on_weapon_state_change(npc,wpn,st,data.weapon_state)
				st.weapon_state = data.weapon_state
			end
		end
	end
end

------------------
-- npc_on_weapon_state_change(npc,weapon,storage)
-------------------
function npc_on_weapon_state_change(npc,wpn,st,state)
	--alun_utils.debug_write("npc_on_weapon_state_change")
	if (intercepts.npc_on_weapon_state_change) then
		for i=1, #intercepts.npc_on_weapon_state_change do
			intercepts.npc_on_weapon_state_change[i](npc,wpn,st,state)
		end
	end
end

------------------
-- npc_on_weapon_no_ammo(npc,weapon,storage)
-------------------
function npc_on_weapon_no_ammo(npc,wpn,st)
	for i=1, #intercepts.npc_on_weapon_no_ammo do
		intercepts.npc_on_weapon_no_ammo[i](npc,wpn,st)
	end
end

------------------
-- npc_on_weapon_sight(npc,weapon,storage)
-------------------
function npc_on_weapon_sight(npc,wpn,st,sight_type)
	for i=1, #intercepts.npc_on_weapon_sight do
		intercepts.npc_on_weapon_sight[i](npc,wpn,st,sight_type)
	end
end

------------------
-- npc_on_weapon_unsight(npc,weapon,storage)
-------------------
function npc_on_weapon_unsight(npc,wpn,st,sight_type)
	for i=1, #intercepts.npc_on_weapon_unsight do
		intercepts.npc_on_weapon_unsight[i](npc,wpn,st,sight_type)
	end
end


-------------------
-- npc_on_weapon_strapped(npc,weapon)
-------------------
function npc_on_weapon_strapped(npc,wpn)
	if (intercepts.npc_on_weapon_strapped) then
		for i=1, #intercepts.npc_on_weapon_strapped do
			intercepts.npc_on_weapon_strapped[i](npc,wpn)
		end
	end
end

-------------------
-- npc_on_weapon_unstrapped(npc,weapon)
-------------------
function npc_on_weapon_unstrapped(npc,wpn)
	if (intercepts.npc_on_weapon_unstrapped) then
		for i=1, #intercepts.npc_on_weapon_unstrapped do
			intercepts.npc_on_weapon_unstrapped[i](npc,wpn)
		end
	end
end

-------------------
-- npc_on_weapon_drop(npc,weapon)
-------------------
function npc_on_weapon_drop(npc,wpn)
	if (intercepts.npc_on_weapon_drop) then
		for i=1, #intercepts.npc_on_weapon_drop do
			intercepts.npc_on_weapon_drop[i](npc,wpn)
		end
	end
end

-------------------
-- npc_on_weapon_fire(npc,weapon)
-------------------
function npc_on_weapon_fire(npc,wpn)
	if (intercepts.npc_on_weapon_fire) then
		for i=1, #intercepts.npc_on_weapon_fire do
			intercepts.npc_on_weapon_fire[i](npc,wpn)
		end
	end
end

-------------------
-- npc_add_precondition(action)
-------------------
function npc_add_precondition(action)
	--alun_utils.debug_write("npc_add_precondition")
	if (intercepts.npc_add_precondition) then
		for i=1, #intercepts.npc_add_precondition do
			intercepts.npc_add_precondition[i](action)
		end
	end
end

-------------------
-- npc_on_hear_callback(obj,who_id,s_type,sound_dist,sound_power,sound_position)
-------------------
function npc_on_hear_callback(obj,who_id,s_type,sound_dist,sound_power,sound_position)
	--alun_utils.debug_write("npc_on_hear_callback")
	if (intercepts.npc_on_hear_callback) then
		for i=1, #intercepts.npc_on_hear_callback do
			intercepts.npc_on_hear_callback[i](obj,who_id,s_type,sound_dist,sound_power,sound_position)
		end
	end
end

-------------------
-- npc_on_hit_callback(npc,amount,local_direction,who,bone_index)
-------------------
function npc_on_hit_callback(npc,amount,local_direction,who,bone_index)
	--alun_utils.debug_write("npc_on_hit_callback")
	if (intercepts.npc_on_hit_callback) then
		for i=1, #intercepts.npc_on_hit_callback do
			intercepts.npc_on_hit_callback[i](npc,amount,local_direction,who,bone_index)
		end
	end
end

-------------------
-- npc_on_death_callback(npc,who)
-------------------
function npc_on_death_callback(npc,who)
	--printf("death_callback for %s killed by %s",npc:name(),who:name())
	--alun_utils.debug_write("npc_on_death_callback")
	if (intercepts.npc_on_death_callback) then
		for i=1, #intercepts.npc_on_death_callback do
			intercepts.npc_on_death_callback[i](npc,who)
		end
	end
end

-------------------
-- npc_on_get_all_from_corpse(npc,corpse)
-------------------
function npc_on_get_all_from_corpse(npc,corpse)
	--alun_utils.debug_write("npc_on_get_all_from_corpse")
	if (intercepts.npc_on_get_all_from_corpse) then
		for i=1, #intercepts.npc_on_get_all_from_corpse do
			intercepts.npc_on_get_all_from_corpse[i](npc,corpse)
		end
	end
end

-------------------
-- npc_on_fighting_actor(npc)
-------------------
function npc_on_fighting_actor(npc)
	if (intercepts.npc_on_fighting_actor) then
		for i=1, #intercepts.npc_on_fighting_actor do
			intercepts.npc_on_fighting_actor[i](npc)
		end
	end
end

--------------------
-- npc_on_item_take_from_box(npc,box,item)
--------------------
function npc_on_item_take_from_box(npc,box_item)
	if (intercepts.npc_on_item_take_from_box) then
		for i=1, #intercepts.npc_on_item_take_from_box do
			intercepts.npc_on_item_take_from_box[i](npc,box,item)
		end
	end
end

-------------------
-- squad_on_update(squad)
-------------------
function squad_on_update(squad)
	if (intercepts.squad_on_update) then
		for i=1, #intercepts.squad_on_update do
			intercepts.squad_on_update[i](squad)
		end
	end
end

-------------------
-- squad_on_npc_creation(squad,npc,smart)
-------------------
function squad_on_npc_creation(squad,npc,smart)
	--alun_utils.debug_write(alun_utils.sr("squad_on_npc_creation squad=%s npc=%s smart=%s",squad and squad:name(),npc and npc:name(),smart and smart:name()))
	if (intercepts.squad_on_npc_creation) then
		for i=1, #intercepts.squad_on_npc_creation do
			intercepts.squad_on_npc_creation[i](squad,npc,smart)
		end
	end
end

-------------------
-- squad_on_npc_death(self,npc,killer)
-------------------
function squad_on_npc_death(squad,npc,killer)
	--alun_utils.debug_write("squad_on_npc_death")
	if (intercepts.squad_on_npc_death) then
		for i=1, #intercepts.squad_on_npc_death do
			intercepts.squad_on_npc_death[i](squad,npc,killer)
		end
	end
end

-------------------
-- squad_on_unregister(self)
-------------------
function squad_on_unregister(squad)
	if (intercepts.squad_on_unregister) then
		for i=1, #intercepts.squad_on_unregister do
			intercepts.squad_on_unregister[i](squad)
		end
	end
end


-------------------
-- squad_can_switch_offline(self)
-------------------
function squad_can_switch_offline(squad,npc)
	if (intercepts.squad_can_switch_offline) then 
		for i=1, #intercepts.squad_can_switch_offline do
			if (intercepts.squad_can_switch_offline[i](squad) == false) then
				return false
			end
		end
	end
end

-------------------
-- squad_assign_new_target(squad)
-------------------
function squad_assign_new_target(squad)
	if (intercepts.squad_assign_new_target) then
		local id
		for i=1, #intercepts.squad_assign_new_target do
			id = intercepts.squad_assign_new_target[i](squad)
			if (id) then
				break
			end
		end
		return id
	end
end

-------------------
-- squad_can_help_actor(squad)
-------------------
function squad_can_help_actor(squad)
	if (intercepts.squad_can_help_actor) then 
		local flag
		for i=1, #intercepts.squad_can_help_actor do
			flag = intercepts.squad_can_help_actor[i](squad)
			if (flag) then
				break
			end
		end
		return flag
	end
end

-------------------
-- squad_on_add_npc(squad,npc,spawn_section,spawn_position,lv_id,gv_id)
-------------------
function squad_on_add_npc(squad,npc,spawn_section,spawn_position,lv_id,gv_id)
	if (intercepts.squad_on_add_npc) then
		for i=1, #intercepts.squad_on_add_npc do
			intercepts.squad_on_add_npc[i](squad,npc,spawn_section,spawn_position,lv_id,gv_id)
		end
	end
end

-------------------
-- set_generic_scheme(npc, ini, stype)
-------------------
function set_generic_scheme(npc, ini, stype)
	--alun_utils.debug_write("set_generic_scheme start")
	if (intercepts.set_generic_scheme) then 
		for i=1, #intercepts.set_generic_scheme do
			intercepts.set_generic_scheme[i](npc, ini,stype)
		end
	end
	--alun_utils.debug_write("set_generic_scheme end")
end

-------------------
-- scheme_reset(npc,scheme,section,st)
-------------------
function scheme_reset(npc,scheme,section,st)
	if (intercepts.scheme_reset) then
		for i=1, #intercepts.scheme_reset do
			intercepts.scheme_reset[i](npc,scheme,section,st)
		end
	end
end

-------------------
-- scheme_disable(npc,stype)
-------------------
function scheme_disable(npc,stype)
	if (intercepts.scheme_disable) then
		for i=1, #intercepts.scheme_disable do
			intercepts.scheme_disable[i](npc,stype)
		end
	end
end

-------------------
-- scheme_deactivate(npc,scheme,st)
-------------------
function scheme_deactivate(npc,scheme,st)
	if (intercepts.scheme_deactivate) then
		for i=1, #intercepts.scheme_deactivate do
			intercepts.scheme_deactivate[i](npc,scheme,st)
		end
	end
end

-------------------
-- monster_on_update(npc,st)
-------------------
function monster_on_update(npc,st)
	--alun_utils.debug_write("monster_on_update")
	if (intercepts.monster_on_update) then
		for i=1, #intercepts.monster_on_update do
			intercepts.monster_on_update[i](npc,st)
		end
	end
end

-------------------
-- monster_on_hit_callback(obj,amount,local_direction,who,bone_index)
-------------------
function monster_on_hit_callback(obj,amount,local_direction,who,bone_index)
	--alun_utils.debug_write("monster_on_hit_callback")
	if (intercepts.monster_on_hit_callback) then
		for i=1, #intercepts.monster_on_hit_callback do
			intercepts.monster_on_hit_callback[i](obj,amount,local_direction,who,bone_index)
		end
	end
end

-------------------
-- monster_on_death_callback(obj,who)
-------------------
function monster_on_death_callback(obj,who)
	--alun_utils.debug_write("monster_on_death_callback")
	if (intercepts.monster_on_death_callback) then
		for i=1, #intercepts.monster_on_death_callback do
			intercepts.monster_on_death_callback[i](obj,who)
		end
	end
end

-------------------
-- monster_on_net_spawn(obj)
-------------------
function monster_on_net_spawn(obj)
	--alun_utils.debug_write("monster_on_net_spawn")
	if (intercepts.monster_on_net_spawn) then
		for i=1, #intercepts.monster_on_net_spawn do
			intercepts.monster_on_net_spawn[i](obj)
		end
	end
end

-------------------
-- monster_on_actor_use_callback(obj,who)
-------------------
function monster_on_actor_use_callback(obj,who)
	if (intercepts.monster_on_actor_use_callback) then
		for i=1, #intercepts.monster_on_actor_use_callback do
			intercepts.monster_on_actor_use_callback[i](obj,who)
		end
	end
end

------------------
-- main_menu_on_init()
------------------
function main_menu_on_init(menu)
	axr_main_options.main_menu_on_init(menu)
	
	if (closecaption and closecaption.main_menu_on_init) then
		closecaption.main_menu_on_init(menu)
	end
	
	if (intercepts.main_menu_on_init) then 
		for i=1, #intercepts.main_menu_on_init do
			intercepts.main_menu_on_init[i](menu)
		end
	end
end

------------------
-- main_menu_on_quit()
------------------
function main_menu_on_quit(menu)
	if (closecaption and closecaption.main_menu_on_quit) then
		closecaption.main_menu_on_quit(menu)
	end
	if (intercepts.main_menu_on_quit) then
		for i=1, #intercepts.main_menu_on_quit do
			intercepts.main_menu_on_quit[i](menu)
		end
	end
end

------------------
-- main_menu_on_keyboard(dik,keyboard_action,self,level_present)
------------------
function main_menu_on_keyboard(dik,keyboard_action,menu,level_present)
	if (intercepts.main_menu_on_keyboard) then
		for i=1, #intercepts.main_menu_on_keyboard do
			intercepts.main_menu_on_keyboard[i](dik,keyboard_action,menu,level_present)
		end
	end
end

------------------
-- opt_menu_on_init()
------------------
function opt_menu_on_init(menu)
	axr_main_options.opt_menu_on_init(menu)

	if (intercepts.opt_menu_on_init) then
		for i=1, #intercepts.opt_menu_on_init do
			intercepts.opt_menu_on_init[i](menu)
		end
	end
end

------------------
-- opt_menu_on_accept()
------------------
function opt_menu_on_accept(menu,optMgr,console)
	axr_main_options.opt_menu_on_accept(menu,optMgr,console)

	if (intercepts.opt_menu_on_accept) then
		for i=1, #intercepts.opt_menu_on_accept do
			intercepts.opt_menu_on_accept[i](menu,optMgr,console)
		end
	end
end

------------------
-- opt_menu_on_set_values()
------------------
function opt_menu_on_set_values(menu,optMgr)
	axr_main_options.opt_menu_on_set_values(menu,optMgr)

	if (intercepts.opt_menu_on_set_values) then
		for i=1, #intercepts.opt_menu_on_set_values do
			intercepts.opt_menu_on_set_values[i](menu,optMgr)
		end
	end
end

------------------
-- physic_object_on_use_callback(obj,who)
------------------
function physic_object_on_use_callback(obj,who)
	if (intercepts.physic_object_on_use_callback) then
		for i=1, #intercepts.physic_object_on_use_callback do
			intercepts.physic_object_on_use_callback[i](obj,who)
		end
	end
end

------------------
-- physic_object_on_hit_callback(obj, amount, local_direction, who, bone_index)
------------------
function physic_object_on_hit_callback(obj, amount, local_direction, who, bone_index)
	if (intercepts.physic_object_on_hit_callback) then
		for i=1, #intercepts.physic_object_on_hit_callback do
			intercepts.physic_object_on_hit_callback[i](obj, amount, local_direction, who, bone_index)
		end
	end
end

-------------------
-- on_save_game_load(fileName)		-- ui_load_dlg.script
-------------------
function on_save_game_load(fname)
	printf("collectgarbage before=%sKb",collectgarbage("count")*1024)
	collectgarbage("collect")
	printf("collectgarbage after=%sKb",collectgarbage("count")*1024)
end

--------------------
-- on_save_game_save(fileName)		-- ui_save_dlg.script
--------------------
function on_save_game_save(fname)
	last_save = fname
	
	-- because the queue does not persist through saves we must force all queued actions to trigger
	event_queue(true)

	--printf("collectgarbage before=%sKb",collectgarbage("count")*1024)
	--collectgarbage("collect")
	--printf("collectgarbage after=%sKb",collectgarbage("count")*1024)
end
