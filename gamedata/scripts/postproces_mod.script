--------------------------------------------------------------------------
--- todo: 

-- effects list

local base_id = 2050
local effects = {
mezaton = {pp = {"mezaton.ppe"},play_time = 3570*1000,tr_time = 12000},
sleep_low = {pp = {"sleep.ppe"},cyclic = true},
sleep_high = {pp = {"blur.ppe"},cyclic = true},
sleep_snd = {snd = {sound_object("actor\\sleep")}},
wakeup_snd = {snd = {sound_object("actor\\wakeup"),2}},
zevok = {pp = {"zevok.ppe"},cam = {"surge_01.anm"},snd = {sound_object("actor\\zevok")},play_time = 7000},
wink = {pp = {"wink.ppe"},play_time = 2000}
}

local upd_time,seldom_upd_time,often_upd_time = 0,0,0
local pret = game.get_game_time()
local last_updt = -100
function update()
	if not db.actor:alive() then
		for n,e in pairs(effects) do
			remove_effect(n,true)
		end
		return
	end
	local tg = time_global()
	local deltag = tg-last_updt
	if deltag >= 63 then
		update_effects(deltag)
		last_updt = tg
	end
	if tg > upd_time then
		local time = game.get_game_time()
		local delta = time:diffSec(pret)
		mezaton_update(delta)
		pret = time
		upd_time = tg+810
		proce = true
	end
	if tg > seldom_upd_time then
		sleep_update()
		seldom_upd_time = tg+6100
	end
	if tg > often_upd_time then
		often_upd_time = tg+544
	end
end

function init_effects()
	for n,e in pairs(effects) do
		if e.pp or e.cam then
			base_id = base_id+1
			e.id = base_id
		end
		if e.pp then
			if not tonumber(e.pp[#e.pp]) then --type(e.pp[#e.pp]) ~= "number"
				table.insert(e.pp,1)
			end
--			e.pp[2] = 1
		end
		if e.snd then
			e.snd[2] = 0
			e.snd[3] = 1
		end
		e.time = 0
		if not e.tr_time then
			if e.cyclic then
				e.tr_time = 5000
			else
				e.tr_time = 1
			end
		end
		if not e.cyclic and not e.play_time then
			e.play_time = e.snd and e.snd[1]:length() or 5000
		end
		if e.update_func then
			e.update_func = loadstring(e.update_func.."(...)")
			setfenv(e.update_func,this)
		end
		if e.callback_func then
			e.callback_func = loadstring(e.callback_func.."(...)")
			setfenv(e.callback_func,this)
		end		
	end
end

local inited
function update_effects(delta)
	if not inited then
		init_effects()
		inited = true
		return
	end
	for n,e in pairs(effects) do
		if e.play or e.ending then
			-- завершение по таймеру
			if not e.cyclic and e.play and e.play_time then
				e.time = e.time+delta
				if e.time > e.play_time then
--					rx_ai.printf("update_effects end callback %s",n)
					if e.callback_func then
						e.callback_func(e)
					end
					remove_effect(n)
				end
			end
			-- изменение фактора
			if e.factor ~= e.target_factor then
				local add = delta/e.tr_time
				if math.max(e.factor,e.target_factor)-math.min(e.factor,e.target_factor) < add then
					e.factor = e.target_factor
				else
					local fr = e.factor < e.target_factor and 1 or -1
					e.factor = e.factor+add*fr
				end
				if e.ending and e.factor < 0.05 then
					remove_effect(n,true)
				else
					if e.pp then
--						rx_ai.printf("set %s factor %s %s %s",n,e.factor,tostring(e.play),tostring(e.ending))
						level.set_pp_effector_factor(e.id,e.factor*e.pp[#e.pp],20)
					end
					if e.snd then
						e.snd[1].volume = e.factor*e.snd[3]
					end
				end
			end
			-- кастом апдейт
			if e.play and e.update_func then
				e.update_func(n,e,delta)
			end
		end
	end
end

function add_effect(name,ef)
	local eff = effects[name]
	if not eff.play then
		local loop = eff.cyclic
		if eff.ending and loop then
--			rx_ai.printf("add_effect %s ending",name)
			eff.ending = nil
			eff.play = true
			eff.target_factor = 1
			return
		end
		eff.target_factor = 1
		eff.factor = 1
		eff.play = true
		if loop then
			eff.factor = 0.01
		end
		if eff.pp and (not ef or ef == "pp") then
			local pe = eff.pp[math.random(1,#eff.pp-1)]
			level.add_pp_effector(pe,eff.id,loop)
			level.set_pp_effector_factor(eff.id,eff.factor*eff.pp[#eff.pp])
		end
		if eff.cam and (not ef or ef == "cam") then
			local ce = eff.cam[math.random(1,#eff.cam)]
			level.add_cam_effector("camera_effects\\"..ce,eff.id,loop)
		end
		local snd = eff.snd
		if snd and (not ef or ef == "snd") then
			snd[1]:play(db.actor,snd[2],loop and sound_object.s2d+sound_object.looped or sound_object.s2d)
			snd[1].volume = snd[3]
		end
	end
end

function remove_effect(name,f)
	local eff = effects[name]
	if f then -- убираем нафиг
		if eff.pp then
			level.remove_pp_effector(eff.id)
		end
		if eff.cam then
			level.remove_cam_effector(eff.id)
		end
		if eff.snd then
			eff.snd[1]:stop()
		end
		eff.ending = nil		
--		rx_ai.printf("remove_effect %s f",name)
	elseif eff.play then -- or (eff.factor and not eff.cyclic)
		eff.ending = true
		eff.target_factor = 0.01
	end
	eff.time = 0
	eff.play = nil
end

function effect_playing(name)
	return effects[name].play
end

function set_ppe_factor(name,factor,f)
	if effects[name].play then
		if factor < 0.01 then
			factor = 0.01
		elseif factor > 1 then
			factor = 1
		end
		if f then
			level.set_pp_effector_factor(effects[name].id,factor,20)
			effects[name].factor = factor
		else
			effects[name].target_factor = factor
		end
	end
end


local max_wake_time = 24*60*60 -- сколько может продержаться без сна. секунды
local drst = pret
local tsleept
local sleepd = nil
function sleep_update()
    local time = game.get_game_time()
	if sleepd ~= nil then
		if sleepd == false then
			sleepd = nil
			drst = time
		end
		return
	end
	local val = xr_logic.pstor_retrieve(db.actor,"drowse",0)
	local add = time:diffSec(drst)/max_wake_time
	drst = time
	val = val+add
	xr_logic.pstor_store(db.actor,"drowse",val)
	local power_in = (1-db.actor.power)/10 -- влияние силы на сонливость
--	rx_ai.printf("drowse:add %s, val = %s,power_in = %s",add,val,power_in) --не спать вне укрытия во время выброса и за пол часа до него
	if val > 1-power_in and (surge_manager.actor_in_cover() or (not surge_manager.is_started() and surge_manager.get_surge_manager()._delta > time:diffSec(surge_manager.get_surge_manager().last_surge_time)+1200)) then -- отруб
		if not tsleept then
			tsleept = time_global()+math.random(5000,20000)
		elseif tsleept < time_global() then
			add_effect("sleep_snd")
			if val > 1.1 then
				ui_sleep_dialog.sleep_forced(math.floor(10*val)) --- нажрались водяры? Спим дольше
			else
				ui_sleep_dialog.sleep_forced()
			end
			sleepd = true
		end
	else
		tsleept = nil
	end
	if val > 0.75-power_in then -- блюр
		remove_effect("sleep_low")
		add_effect("sleep_high")
		set_ppe_factor("sleep_high",(val-0.7)*4)
		local m = math.random(100)
		if m > 91 then -- зевок
			add_effect("zevok")
		elseif m > 60 then
			add_effect("wink")
			set_ppe_factor("sleep_high",0.1,true)
		end
	elseif val > 0.5-power_in then -- двоение
		remove_effect("sleep_high")
		add_effect("sleep_low")
		local m = math.random(100)
		if m == 100 then -- зевок
			add_effect("zevok","snd")
		end
		if m > 95 then
			add_effect("zevok","pp")
		elseif m > 70 then
			add_effect("wink")
		end
	else
		remove_effect("sleep_high")
		remove_effect("sleep_low")
	end
end

-- With this table, the first value is the chance this mutant will attack (spawn), the second is the minimum amount and the third is the maximum. So by default there's a 10% chance of 4 to 10 tushkano spawning, but only a 5% chance of a single chimera. Snorks will always attack as a duo etc.
local surprise_list = {bloodsucker_weak = {10,1,1},
						boar_normal = {20,1,3},
						dog_normal = {20,2,5},
						flesh_normal = {15,1,4}, -- Flesh aren't normally predatory, but a sleeping stalker is easy prey, right?
						pseudodog_normal = {15,1,2},
						tushkano_normal = {10,4,10},
						chimera_normal = {5,1,1},
						snork_weak = {5,2,2}}

function sleep_callback(hours,mins,forced,bag)
	sleepd = false
	add_effect("wakeup_snd")
	local val = xr_logic.pstor_retrieve(db.actor,"drowse",0)
	val = val-hours/10-mins/600
	if val < 0 then
		val  = 0
	end
	xr_logic.pstor_store(db.actor,"drowse",val)
	val = xr_logic.pstor_retrieve(db.actor,"drowse_cut",0)
	val = val-hours/16-mins/960
	if val < 0 then
		val  = 0
	end
	xr_logic.pstor_store(db.actor,"drowse_cut",val)
	if itms_manager.sleep_actor_safe or surge_manager.actor_in_cover() then
		return
	end -- If we're in a safe area or in "cover", then we stop this function early, thus making it impossible for a mutant to attack us.
	local add = 0
	if forced then
		add = 20 -- If we collapse, there's a greater chance of a mutant finding us. Why? THE ZONE!
	end
	local rnd = 0
	local tmp = {}
	for k,v in pairs(surprise_list) do
		rnd = rnd+v[1]
		table.insert(tmp,{sec = k,rnd = rnd})
	end
	rnd = math.random(rnd) + add -- Random chance is the first variable in the suprise_list table plus the "add". So, for example, a chimera has a 25% chance of spawning if we collapse out somewhere unsafe. A dog has a 40% chance of spawning. If we don't collapse, it's 5% and 20% respectively.
	if bag and bag == "compression_bag" then
		rnd = rnd * 0.6 -- Compression bag leaves less of a footprint, thus less chance of a mutant finding you.
	end
	local pre = 0
	for k,v in ipairs(tmp) do
		if rnd >= pre and rnd < v.rnd then
			local sim = alife()
			local actor_pos,actor_lvid,actor_gvid = db.actor:position(),db.actor:level_vertex_id(),db.actor:game_vertex_id()
			for i=1,math.random(surprise_list[v.sec][2],surprise_list[v.sec][3]) do
				local pos = vector():set(actor_pos):add(vector():set(math.random(4,9),0,math.random(4,9)))
				sim:create(v.sec,pos,actor_lvid,actor_gvid)
--				rx_ai.printf("spawn: %s",v.sec)
			end
			break
		else
			pre = v.rnd
		end
	end
end

function mezaton_update(delta)
	-- mezaton
	local val = xr_logic.pstor_retrieve(db.actor,"mez",nil)
	if val then
		local add = delta/4800
		val = val-add
		if val <= 0 then
			remove_effect("mezaton")
			db.storage[0].pstor.mez = nil
		else
			xr_logic.pstor_store(db.actor,"mez",val)
			add_effect("mezaton")
		end
	end
end
--[[------ Сдесь определяется сонливость в зависимоти от принятых на грудь литров водки или энергетиков. В принципе можете добавлять любой предмет который можно "съесть". я добавил некоторые медикаменты --]] ------
local obj_table = {}
function use_obj(obj)
	local s = obj:section()
	if not obj_table[s] then
		obj_table[s] = {}
		obj_table[s].sleepiness = alun_utils.read_from_ini(nil,s,"eat_sleepiness","float",0)
	end
	if obj_table[s].sleepiness ~= 0 then
		use_sleepiness(obj_table[s].sleepiness)
	end
	use_mezaton(s)
end

function use_sleepiness(add)
	local val = xr_logic.pstor_retrieve(db.actor,"drowse_cut",0)
	if val >= 1 and add < 0 then
		return -- если лимит использования энeргеников исчерпан
	end
	if add < 0 then
		xr_logic.pstor_store(db.actor,"drowse_cut",val-add)
	end
	val = xr_logic.pstor_retrieve(db.actor,"drowse",0)+add
	if val < 0 then
		val = 0
	end
	xr_logic.pstor_store(db.actor,"drowse",val)
end

function use_mezaton(s)
	if s == "drug_mezaton" then
		add_effect("mezaton")
		xr_logic.pstor_store(db.actor,"mez",1)
		mezt = game.get_game_time()
	end
end
