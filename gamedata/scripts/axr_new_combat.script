--[[
	scheme_type: generic
	author: Alundaio
--]]

--TODO: Fix heli aim targetting!

-- disable it entirely
local ENABLE = true

-- all ranks will use script and at highest level of AI
local IGNORE_RANK = true

-- all npcs will use this combat behavior
local GLOBAL_OVERRIDE = false

--------------------------------------
actid = 188115
evaid = 188115
--------------------------------------
local math_random = math.random

-------------------------------------------------------------------------------------
--												PRIVATE
--------------------------------------------------------------------------------------


local good_acts = {
					[xr_actions_id.smartcover_action] = true,
					[xr_actions_id.smartcover_action+2] = true
					}

local function find_valid_target(npc,st,bw)
	if (st.overflowdetect) then
		printf("C Stack Overflow Prevention: warning axr_new_combat scheme making repeated calls without return; save now and reload!")
		return false
	end
	
	-- Evaluate current target
	local tg = time_global()
	local current_target = st.target_id and db.storage[st.target_id] and db.storage[st.target_id].object
	if (current_target) then
		local mem_time = npc:memory_time(current_target)
		if (mem_time == nil or tg-mem_time > 12000 or current_target:alive() ~= true or xr_wounded.is_wounded(current_target) or not xr_combat_ignore.is_enemy(npc,current_target)) then
			st.target_id = nil
			current_target = nil
		end
	end
	
	-- Keep target for short duration to prevent over evaluating and to prevent constant target switching
	if (current_target) then 
		if (st.__keep_target_until and tg < st.__keep_target_until) then 
			return true
		end
	end 
	
	if not (st.index) then
		st.index = 1
	end

	if not (st.memory) then
		st.memory = {}
	end

	local size = #st.memory
	if (size == 0) then
		local i = 0
		local obj

		-- Create a list of valid targets to iterate through one index per update
		st.overflowdetect = true
		for o in npc:memory_visible_objects() do
			obj = o and o:object()
			if (obj and (IsStalker(obj) or IsMonster(obj)) and obj:alive() and npc:relation(obj) >= game_object.enemy) then
				i = i + 1
				table.insert(st.memory,obj:id())
			end
		end
		st.overflowdetect = nil
		if (i==0) then
			return current_target ~= nil
		end

		size = i
	end

	if (size == 0 or st.index > size) then
		st.index = 1
		clear_table(st.memory)
		return current_target ~= nil
	end

	local id = st.memory[st.index]
	st.index = st.index + 1

	-- current target was already evaluated and passed
	if (current_target and id == current_target:id()) then 
		return true
	end 
	
	local target = id and (db.storage[id] and db.storage[id].object or level.object_by_id(id))

	-- Evaluate currently indexed target
	if (target and target:alive() and not xr_wounded.is_wounded(target) and npc:memory_time(target) and tg-npc:memory_time(target) <= 12000) then
		if (current_target) then
			local dist = npc:position():distance_to_sqr(target:position())
			local be_dist = npc:position():distance_to_sqr(current_target:position())
			
			-- Only target the closest target
			if (dist < be_dist and xr_combat_ignore.is_enemy(npc,target) == true) then
				--printf("closer target %s",target and target:name())
				st.target_id = target:id()
				st.__keep_target_until = tg + 6000
				return true
			end
		elseif (xr_combat_ignore.is_enemy(npc,target) == true) then 
			st.__keep_target_until = tg + 6000
			st.target_id = target:id()
			return true
		end
	end
	
	return current_target ~= nil
end

local function check_overrides(npc)
	local id = npc:id()
	local st = db.storage[id] and db.storage[id].overrides
	if not (st) then
		return false
	end
	local script_combat_type = st and st.combat_type and xr_logic.pick_section_from_condlist(db.actor, npc, st.combat_type.condlist)
	return script_combat_type and script_combat_type == "new_combat" or false
end 

--------------------------------------------------------------------------------------
--												EVALUATOR NEW COMBAT
--------------------------------------------------------------------------------------

class "evaluator_new_combat" (property_evaluator)
function evaluator_new_combat:__init(npc,name,storage) super (nil, name)
	self.st = storage
	self.st.stage = 0
end

function evaluator_new_combat:evaluate()
	--alun_utils.debug_write("eva_new_combat")
	local npc = self.object
	if good_acts[npc:motivation_action_manager():current_action_id()] then
		return false
	end
	
	if (db.storage[npc:id()].active_scheme == "camper") then 
		return false 
	end
	
	self.st.rank = IGNORE_RANK and "master" or not self.st.rank and ranks.get_obj_rank_name(obj) or self.st.rank
	
	local be = npc:best_enemy()
	if not (be) then 
		return false 
	end

	local npc = self.object
	local best_weapon = npc:best_weapon()
	local clsid = best_weapon and best_weapon:clsid()
	if (best_weapon) and (GLOBAL_OVERRIDE or not alun_utils.isRifle(nil,clsid) or check_overrides(npc)) then
		if (find_valid_target(npc,self.st) == true) then 
			self.st.bw = best_weapon
			--printf("has target %s",self.st.target_id and db.storage[self.st.target_id] and db.storage[self.st.target_id].object and db.storage[self.st.target_id].object:name())
			return true		
		end
		--alun_utils.debug_write("after find valid target 2")
	end

	return false
end

--------------------------------------------------------------------------------------
--												UTILITY
--------------------------------------------------------------------------------------


--------------------------------------------------------------------------------------
--												ACTION RUSH ATTACK
--------------------------------------------------------------------------------------

class "action_new_combat" (action_base)
function action_new_combat:__init (npc,name,storage) super (nil,name)
	self.st = storage
	self.st.__node_stage = 1
end
function action_new_combat:initialize()
	action_base.initialize(self)
	local npc = self.object
	local sm = db.storage[npc:id()].state_mgr
	if (sm and sm.target_state ~= "assault") then
		npc:clear_animations()
		sm:set_state("assault",nil,nil,nil, {fast_set = true})
		sm.animation:set_state(nil, true)
		sm.animation:set_control()
	end	
	npc:set_desired_position()
	npc:set_desired_direction()
end

function action_new_combat:iterate_nodes()
	if not (self.st.nodes) then 
		return 
	end
	
	--alun_utils.printf("iterating flank nodes")
	
	if (self.object:level_vertex_id() ~= self.st.nodes[self.st.__node_stage]) then 
		self.st.nodes[self.st.__node_stage] = utils.send_to_nearest_accessible_vertex(self.object,self.st.nodes[self.st.__node_stage])
		return
	end
	
	if (self.st.__node_stage + 1 <= #self.st.nodes) then
		self.st.nodes[self.st.__node_stage+1] = utils.send_to_nearest_accessible_vertex(self.object,self.st.nodes[self.st.__node_stage+1])
		self.st.__node_stage = self.st.__node_stage + 1
		return
	end
	
	self.st.nodes = nil
end 

function action_new_combat:try_to_flank(npc,enemy,ene_pos,see,dist)
	--alun_utils.debug_nearest(npc,"try to flank")
	
	if not (self.st.nodes) then 
		self.st.nodes = {}
	end 
	
	local side = random_choice(1,-1)
	
	local pos = npc:position()
	local dir = pos:sub(ene_pos)
	
	local base_point = npc:level_vertex_id()
	local base_vertex_id = level.vertex_in_direction(base_point, vector_rotate_y(utils.vector_copy_by_val(dir),side*90),dist/3)
	local base_position = level.vertex_position(base_vertex_id)

	for i=1,2 do
		local cover, tcover
		local cover_dist = math.floor(dist/3)
		while not cover and cover_dist > 0 do
			cover = npc:best_cover(base_position,ene_pos,cover_dist,1,dist)
			cover_dist = cover_dist - 1
		end

		if (cover) then 
			if (tcover) then 
				self.st.nodes[i] = tcover.cover_vertex_id
			else 
				self.st.nodes[i] = cover:level_vertex_id()
			end
		else 
			self.st.nodes[i] = base_vertex_id
		end
		
		base_position = level.vertex_position(self.st.nodes[i])
	end
	
	local vid = level.vertex_id(ene_pos)
	self.st.nodes[3] = vid and vid < 4294967295 and npc:accessible(vid) and vid or self.st.nodes[2]
end 

function action_new_combat:set_fire_type(dist)
	
	local can_set = true
	local tg = time_global()
	
	self.st.__keep_fire_type_until = not self.st.__keep_fire_type_until and tg+3000 or self.st.__keep_fire_type_until
	if (self.st.__keep_fire_type_until and tg < self.st.__keep_fire_type_until) then
		can_set = false
	end
	self.st.__keep_fire_type_until = nil
	
	-- TODO: Maybe read fire queue params from system_ini()
	
	local aim = dist*2
	
	local bw = self.st.bw or npc:best_weapon()
	if (alun_utils.isShotgun(bw)) then 
		self.st.__fire_type = (self.st.__fire_type == nil or can_set) and math_random(1,2) or self.st.__fire_type
		self.st.__fire_range = 1600
		self.st.__fire_queue = (aim <= 500 and 500 or aim >= 7500 and 7500 or aim) + math_random(100,500)
	elseif (alun_utils.isSniper(bw)) then 
		self.st.__fire_type = 1
		self.st.__fire_range = 250000
		self.st.__fire_queue = (aim <= 2000 and 2000 or aim >= 7500 and 7500 or aim) + math_random(100,500)
	elseif (alun_utils.isRifle(bw)) then 
		self.st.__fire_type = (self.st.__fire_type == nil or can_set) and math_random(1,5) or self.st.__fire_type
		self.st.__fire_range = 22500
		self.st.__fire_queue = (aim <= 500 and 500 or aim >= 3500 and 3500 or aim) + math_random(100,500)
	elseif (alun_utils.isPistol(bw)) then 
		self.st.__fire_type = (self.st.__fire_type == nil or can_set) and math_random(1,3) or self.st.__fire_type
		self.st.__fire_range = 3600
		self.st.__fire_queue = (aim <= 500 and 500 or aim >= 7500 and 7500 or aim) + math_random(100,500)
	else
		self.st.__fire_range = 22500
		self.st.__fire_type = 1
		self.st.__fire_queue = (aim <= 2000 and 2000 or aim >= 7500 and 7500 or aim) + math_random(100,500)
	end
end

function action_new_combat:set_item(npc,enemy,ene_pos,see,dist)
	local tg = time_global()
	local npc_see = npc:see(enemy) or tg-npc:memory_time(enemy) <= 3000
	local vec
	if (npc_see) then 
		vec = alun_utils.safe_bone_pos(enemy,"bip01_spine")
	else
		vec = ene_pos
	end
	
	npc:set_sight(look.fire_point,vec)
	self:set_fire_type(dist)
	
	local bw = self.st.bw or npc:best_weapon()
	
	-- Aim or Shoot depending on distance or enemy visibility of npc
	if (IsStalker(enemy) and not see) then
		npc:set_item(object.aim1,bw)
	elseif (npc_see) and (dist <= 400 or see and dist <= (self.st.__fire_range or 1600)) then
		npc:set_item(object.fire1,bw,self.st.__fire_type or 1,self.st.__fire_queue or 1500)
	else
		npc:set_item(object.aim1,bw)
	end
end

function action_new_combat:try_go_cover_reload(npc,ene_pos)
	--alun_utils.debug_nearest(npc,"try_go_cover_reload")
	local bw = self.st.bw or npc:best_weapon()
	
	-- Try to move to close cover to reload
	if (bw:get_ammo_in_magazine() == 0) then
		local vid = alun_utils.find_close_cover(npc,npc:position(),ene_pos)
		if (vid) then
			self.st.__keep_point_until = time_global() + 4000
			return utils.send_to_nearest_accessible_vertex(npc,vid, "axr_new_combat")
		end
	end
end

function action_new_combat:try_go_cover(npc,enemy,ene_pos,dist)
	--alun_utils.debug_nearest(npc,"try_go_cover")
	if (npc:see(enemy) or time_global() - npc:memory_time(enemy) <= 5000) then 
		return 
	end 
	
	local vid = alun_utils.find_close_cover(npc,npc:position(),ene_pos)
	if (vid and level.vertex_position(vid):distance_to_sqr(npc:position()) < dist) then
		self.st.__keep_point_until = time_global() + 4000
		return utils.send_to_nearest_accessible_vertex(npc,vid, "axr_new_combat")
	end
end

function action_new_combat:try_to_facer(npc,enemy,ene_pos,dist)
	--alun_utils.debug_nearest(npc,"try_to_facer")
	-- Check if NPC can use facer on target; Use method only on stalker since mutants move too fast
	if (IsStalker(enemy)) then
		local f = db.storage[npc:id()] and db.storage[npc:id()].facer
		if (xrs_facer) and (not (f and f.abtime and f.abtime > time_global())) then 
			if (dist <= 3) then
				-- close enough already
				return utils.send_to_nearest_accessible_vertex(npc,npc:level_vertex_id(), "axr_new_combat")
			elseif (dist <= 400) then
				local vid = level.vertex_id(ene_pos)
				vid = vid and vid < 4294967295 and npc:accessible(vid) and vid
				if (vid) then
					return utils.send_to_nearest_accessible_vertex(npc,vid, "axr_new_combat")
				end
			end
		end
	end
end

function action_new_combat:try_to_strafe(npc,enemy,ene_pos,dist)
	--alun_utils.debug_nearest(npc,"try_to_strafe")
	local dir = {}
	dir[1] = vector_rotate_y(utils.vector_copy_by_val(npc:direction()),-90)
	dir[2] = vector_rotate_y(utils.vector_copy_by_val(npc:direction()),90)
	local vid
	local radius = 5
	local base_point = npc:level_vertex_id()
	
	for i=1,2 do
		while (radius <= 15) do
			vid = level.vertex_in_direction(base_point,dir[i],radius)
			if (vid and vid < 4294967295 and npc:accessible(vid)) then 
				return utils.send_to_nearest_accessible_vertex(npc,vid,"axr_new_combat")
			end
			radius = radius + 1
		end
	end
end

function action_new_combat:try_to_strafe_behind_enemy(npc,enemy,ene_pos,dist)
	--alun_utils.debug_nearest(npc,"try_to_strafe_behind_enemy")
	local dir = vector_rotate_y(utils.vector_copy_by_val(enemy:direction()),180)
	local vid
	local radius = 8
	local base_point = npc:level_vertex_id()
	while (radius > 0) do
		vid = level.vertex_in_direction(base_point,dir,radius)
		if (vid and vid < 4294967295 and npc:accessible(vid)) then 
			return utils.send_to_nearest_accessible_vertex(npc,vid,"axr_new_combat")
		end
		radius = radius - 1
	end
end

function action_new_combat:try_go_enemy_position(npc,enemy,ene_pos)
	--alun_utils.debug_nearest(npc,"try_go_enemy_position")
	local vid = level.vertex_id(ene_pos)
	vid = vid and vid < 4294967295 and vid or self:try_go_cover(npc,enemy,ene_pos,2500) or npc:level_vertex_id()
	return utils.send_to_nearest_accessible_vertex(npc,vid, "axr_new_combat")
end

function action_new_combat:try_go_backward(npc)
	--alun_utils.debug_nearest(npc,"try_go_backward")
	local dir = vector_rotate_y(utils.vector_copy_by_val(npc:direction()),math_random(160,200))
	local vid
	local radius = 8
	local base_point = npc:level_vertex_id()
	while (radius > 0) do
		vid = level.vertex_in_direction(base_point,dir,radius)
		if (vid and vid < 4294967295 and npc:accessible(vid)) then
			self.st.__keep_point_until = time_global() + 4000
			return utils.send_to_nearest_accessible_vertex(npc,vid,"axr_new_combat")
		end
		radius = radius - 1
	end
end

function action_new_combat:try_go_cover_forward(npc,ene_pos)
	--alun_utils.debug_nearest(npc,"try_go_cover_forward")
	local dir = vector_rotate_y(utils.vector_copy_by_val(npc:direction()),math_random(-25,25))
	local vid
	local radius = 8
	local base_point = npc:level_vertex_id()
	while (radius > 0) do
		vid = level.vertex_in_direction(base_point,dir,radius)
		if (vid and vid < 4294967295 and npc:accessible(vid)) then 
			--return utils.send_to_nearest_accessible_vertex(npc,vid,"axr_new_combat")
			break
		end
		radius = radius - 1
	end
	
	if not (vid) then 
		return 
	end 
	
	local base_position = level.vertex_position(vid)
	local cover, tcover
	local cover_dist = 30
	while not cover and cover_dist > 0 do
		cover = npc:best_cover(base_position,ene_pos,cover_dist,1,150)
		cover_dist = cover_dist - 1
	end
	
	vid = cover and (tcover and tcover.cover_vertex_id or cover:level_vertex_id()) or vid

	if (vid) then 
		self.st.__keep_point_until = time_global() + 4000
		return utils.send_to_nearest_accessible_vertex(npc,vid,"axr_new_combat")
	end 
end

function action_new_combat:try_go_cover_backward(npc,ene_pos)
	--alun_utils.debug_nearest(npc,"try_go_cover_backward")
	local dir = vector_rotate_y(utils.vector_copy_by_val(npc:direction()),math_random(160,200))
	local vid
	local radius = 8
	local base_point = npc:level_vertex_id()
	while (radius > 0) do
		vid = level.vertex_in_direction(base_point,dir,radius)
		if (vid and vid < 4294967295 and npc:accessible(vid)) then 
			--return utils.send_to_nearest_accessible_vertex(npc,vid,"axr_new_combat")
			break
		end
		radius = radius - 1
	end
	
	if not (vid) then 
		return 
	end 
	
	local base_position = level.vertex_position(vid)
	local cover, tcover
	local cover_dist = 30
	while not cover and cover_dist > 0 do
		cover = npc:best_cover(base_position,ene_pos,cover_dist,1,150)
		cover_dist = cover_dist - 1
	end
	
	vid = cover and (tcover and tcover.cover_vertex_id or cover:level_vertex_id()) or vid

	if (vid) then 
		self.st.__keep_point_until = time_global() + 4000
		return utils.send_to_nearest_accessible_vertex(npc,vid,"axr_new_combat")
	end 
end

function action_new_combat:set_body_state(npc,bod)
	local tg = time_global()
	self.st.__keep_body_state_until = not self.st.__keep_body_state_until and tg+2000 or self.st.__keep_body_state_until
	if (self.st.__keep_body_state_until and tg < self.st.__keep_body_state_until) then 
		return 
	end
	self.st.__keep_body_state_until = nil
	npc:set_body_state(bod)
end

function action_new_combat:set_movement_type(npc,mov)
	local tg = time_global()
	self.st.__keep_movement_type_until = not self.st.__keep_movement_type_until and tg+2000 or self.st.__keep_movement_type_until
	if (self.st.__keep_movement_type_until and tg < self.st.__keep_movement_type_until) then
		return 
	end
	self.st.__keep_movement_type_until = nil
	npc:set_movement_type(mov)
end

function action_new_combat:low_level_ai_execute(npc,enemy,dist)
	self.st.vid = self.st.vid or self:try_go_cover_reload(npc,ene_pos)
	if (self.st.vid == nil) then
		if (dist <= 400) then 
			self:set_body_state(npc,move.standing)
			self:set_movement_type(npc,move.run)
			self.st.vid = self:try_go_cover_backward(npc,ene_pos) or self:try_go_cover(npc,enemy,ene_pos,dist)
			return
		elseif (dist <= 900) then 
			self:set_body_state(npc,move.standing)
			self:set_movement_type(npc,move.walk)
			self.st.vid = self:try_go_cover_backward(npc,ene_pos) or self:try_go_cover(npc,enemy,ene_pos,dist)
			return
		else
			self:set_body_state(npc,move.crouch)
			self:set_movement_type(npc,move.walk)
			self.st.vid = self:try_go_cover_forward(npc,ene_pos) or self:try_go_enemy_position(npc,enemy,ene_pos) or utils.send_to_nearest_accessible_vertex(npc,npc:level_vertex_id(), "axr_new_combat")
			return
		end
	end
end 

function action_new_combat:med_level_ai_execute(npc,enemy,dist)
	self.st.vid = self:try_to_facer(npc,enemy,ene_pos,dist)
	self.st.vid = self.st.vid or self:try_go_cover_reload(npc,ene_pos)
	if (self.st.vid == nil) then
		if (dist <= 400) then 
			self:set_body_state(npc,move.standing)
			self:set_movement_type(npc,move.run)
			self.st.vid = self:try_go_cover_backward(npc,ene_pos) or self:try_go_cover(npc,enemy,ene_pos,dist)
			return
		elseif (dist <= 900) then 
			self:set_body_state(npc,move.standing)
			self:set_movement_type(npc,move.walk)
			self.st.vid = self:try_go_cover_backward(npc,ene_pos) or self:try_go_cover(npc,enemy,ene_pos,dist)
			return
		else
			self:set_body_state(npc,move.crouch)
			self:set_movement_type(npc,move.walk)
			self.st.vid = self:try_go_cover_forward(npc,ene_pos) or self:try_go_enemy_position(npc,enemy,ene_pos) or utils.send_to_nearest_accessible_vertex(npc,npc:level_vertex_id(), "axr_new_combat")
			return
		end
	end
end 

function action_new_combat:high_level_ai_execute(npc,enemy,ene_pos,see,dist)
	--if not (see) then 
		--self:try_to_flank(npc,enemy,ene_pos,see,dist)
		--return
	--end 
	
	self.st.vid = self:try_to_facer(npc,enemy,ene_pos,dist)
	self.st.vid = self.st.vid or self:try_go_cover_reload(npc,ene_pos)
	
	if (self.st.vid == nil) then
		local bw = self.st.bw or npc:best_weapon()
		if (alun_utils.isSniper(bw) or alun_utils.isLauncher(bw)) then 
			if (dist <= 2500) then 
				self:set_body_state(npc,move.standing)
				self:set_movement_type(npc,move.run)
				self.st.vid = self:try_go_cover_backward(npc,ene_pos) or self:try_go_cover(npc,enemy,ene_pos,dist)
				return
			elseif (dist <= 6400) then
				self:set_body_state(npc,move.standing)
				self:set_movement_type(npc,move.walk)
				local npc_see = npc:see(enemy)
				self.st.vid = (npc_see and self:try_go_cover_backward(npc,ene_pos) or self:try_go_cover_forward(npc,ene_pos)) or self:try_go_cover(npc,enemy,ene_pos,dist)
				return
			else
				self:set_body_state(npc,move.crouch)
				self:set_movement_type(npc,move.walk)
				self.st.vid = self:try_go_cover_forward(npc,ene_pos) or utils.send_to_nearest_accessible_vertex(npc,npc:level_vertex_id(), "axr_new_combat")
				return
			end
		elseif (alun_utils.isRifle(bw)) then
			if (dist <= 64) then
				self:set_body_state(npc,move.standing)
				self:set_movement_type(npc,move.walk)
				if (IsStalker) then
					if not (see) then 
						self.st.vid = self:try_to_strafe_behind_enemy(npc,enemy,ene_pos,dist) or self:try_go_cover(npc,enemy,ene_pos,dist) or utils.send_to_nearest_accessible_vertex(npc,npc:level_vertex_id(), "axr_new_combat")
					else
						self.st.vid = self:try_go_cover(npc,enemy,ene_pos,dist) or utils.send_to_nearest_accessible_vertex(npc,npc:level_vertex_id(), "axr_new_combat")
					end
				else
					local ef_creature_type = alun_utils.read_from_ini(nil,enemy:section(),"ef_creature_type","float",0)
					if (ef_creature_type >= 18) then 
						self:set_body_state(npc,move.standing)
						self:set_movement_type(npc,move.run)
						self.st.vid = self:try_go_cover_backward(npc,ene_pos) or self:try_go_cover(npc,enemy,ene_pos,dist)
						return
					end 
					self.st.vid = self:try_go_cover(npc,enemy,ene_pos,dist) or utils.send_to_nearest_accessible_vertex(npc,npc:level_vertex_id(), "axr_new_combat")
				end
				return
			elseif (dist <= 400) then
				if (see) then
					self:set_body_state(npc,move.standing)
					self:set_movement_type(npc,move.walk)
				else 
					self:set_body_state(npc,move.crouch)
					self:set_movement_type(npc,move.run)
				end
				if (IsStalker) then 
					self.st.vid = self:try_to_strafe(npc,enemy,ene_pos,dist) or self:try_go_cover(npc,enemy,ene_pos,dist) or utils.send_to_nearest_accessible_vertex(npc,npc:level_vertex_id(), "axr_new_combat")
				else
					local ef_creature_type = alun_utils.read_from_ini(nil,enemy:section(),"ef_creature_type","float",0)
					if (ef_creature_type >= 18) then 
						self:set_body_state(npc,move.standing)
						self:set_movement_type(npc,move.run)
						self.st.vid = self:try_go_cover_backward(npc,ene_pos) or self:try_go_cover(npc,enemy,ene_pos,dist)
						return
					end 
					self.st.vid = self:try_go_cover(npc,enemy,ene_pos,dist) or utils.send_to_nearest_accessible_vertex(npc,npc:level_vertex_id(), "axr_new_combat")
				end
				return
			elseif (dist <= 2500) then 
				self:set_body_state(npc,move.standing)
				self:set_movement_type(npc,move.walk)
				self.st.vid = self:try_go_cover(npc,enemy,ene_pos,dist) or self:try_go_enemy_position(npc,enemy,ene_pos) or utils.send_to_nearest_accessible_vertex(npc,npc:level_vertex_id(), "axr_new_combat")
			else
				self:set_body_state(npc,move.standing)
				self:set_movement_type(npc,move.run)
				self.st.vid = self:try_go_enemy_position(npc,enemy,ene_pos) or self:try_go_cover_forward(npc,ene_pos)
			end
			return
		elseif (alun_utils.isShotgun(bw)) then
			--alun_utils.debug_nearest(npc,"isShotgun")
			if (IsStalker(enemy)) then
				if (dist <= 3) then
					self:set_body_state(npc,move.crouch)
					self:set_movement_type(npc,move.walk)
					self.st.vid = self:try_to_strafe(npc,enemy,ene_pos,dist) or utils.send_to_nearest_accessible_vertex(npc,npc:level_vertex_id(), "axr_new_combat")
					self.st.__keep_point_until = time_global() + 5000
					return
				elseif (dist <= 49) then
					if (see) then
						self:set_body_state(npc,move.standing)
						self:set_movement_type(npc,move.walk)
					else 
						self:set_body_state(npc,move.crouch)
						self:set_movement_type(npc,move.run)
					end
					self.st.vid = self:try_to_strafe_behind_enemy(npc,enemy,ene_pos,dist) or self:try_go_cover(npc,enemy,ene_pos,dist) or utils.send_to_nearest_accessible_vertex(npc,npc:level_vertex_id(), "axr_new_combat")
					return
				end
			else 
				local ef_creature_type = alun_utils.read_from_ini(nil,enemy:section(),"ef_creature_type","float",0)
				if (ef_creature_type >= 18) then 
					if (dist <= 400) then 
						self:set_body_state(npc,move.standing)
						self:set_movement_type(npc,move.run)
						self.st.vid = self:try_go_cover_backward(npc,ene_pos) or self:try_go_cover(npc,enemy,ene_pos,dist)
						return
					elseif (dist <= 900) then
						self:set_body_state(npc,move.standing)
						self:set_movement_type(npc,move.walk)
						self.st.vid = self:try_go_cover_backward(npc,ene_pos) or self:try_go_cover(npc,enemy,ene_pos,dist)
					end
					self:set_movement_type(npc,move.walk)
					self:set_body_state(npc,move.standing)
					self.st.vid = self:try_go_enemy_position(npc,enemy,ene_pos)		
					return 
				end 
				if (dist <= 3) then
					self:set_body_state(npc,move.standing)
					self:set_movement_type(npc,move.walk)
					self.st.vid = self:try_go_backward(npc) or self:try_to_strafe(npc,enemy,ene_pos,dist) or utils.send_to_nearest_accessible_vertex(npc,npc:level_vertex_id(), "axr_new_combat")
					return
				elseif (dist <= 49) then 
					self:set_body_state(npc,move.crouch)
					self:set_movement_type(npc,move.walk)
					self.st.vid = utils.send_to_nearest_accessible_vertex(npc,npc:level_vertex_id(), "axr_new_combat")
					self.st.__keep_point_until = time_global() + 5000
					return
				elseif (dist <= 400) then 
					self:set_movement_type(npc,move.walk)
					self:set_body_state(npc,move.standing)
					self.st.vid = self:try_go_enemy_position(npc,enemy,ene_pos) or self:try_go_cover_forward(npc,ene_pos)
					return
				end
			end
			self:set_body_state(npc,move.standing)
			self.st.vid = self:try_go_enemy_position(npc,enemy,ene_pos) or self:try_go_cover_forward(npc,ene_pos)
			self:set_movement_type(npc,move.run)
			return
		else
			if (dist <= 400) then 
				self:set_body_state(npc,move.standing)
				self:set_movement_type(npc,move.run)
				self.st.vid = self:try_go_cover_backward(npc,ene_pos) or self:try_go_cover(npc,enemy,ene_pos,dist)
				return
			elseif (dist <= 900) then 
				self:set_body_state(npc,move.standing)
				self:set_movement_type(npc,move.walk)
				self.st.vid = self:try_go_cover_backward(npc,ene_pos) or self:try_go_cover(npc,enemy,ene_pos,dist)
				return
			else
				self:set_body_state(npc,move.crouch)
				self:set_movement_type(npc,move.walk)
				self.st.vid = self:try_go_cover(npc,enemy,ene_pos,dist) or self:try_go_enemy_position(npc,enemy,ene_pos) or utils.send_to_nearest_accessible_vertex(npc,npc:level_vertex_id(), "axr_new_combat")
				return
			end
		end
	end
		
	self.st.vid = self.st.vid or self:try_go_cover(npc,enemy,ene_pos,dist)
	self:set_movement_type(npc,move.walk)
end 

function action_new_combat:execute()
	action_base.execute(self)
	
	local npc = self.object
	local enemy = self.st.target_id and (db.storage[self.st.target_id] and db.storage[self.st.target_id].object or level.object_by_id(self.st.target_id))
	
	--alun_utils.printf("rush attack")
	
	if not (enemy and enemy:alive()) then
		self.st.target_id = nil
		return
	end
	
	-- ensure and enforce path type
	if (npc:path_type() ~= game_object.level_path) then 
		npc:set_path_type(game_object.level_path)
	end
	
	local tg = time_global()
	
	npc:set_mental_state(anim.danger)
	npc:set_movement_type(move.run)
	
	local ene_pos = npc:memory_position(enemy) or enemy:position()
	local dist = ene_pos:distance_to_sqr(npc:position())
	local mem_time = enemy:memory_time(npc)
	local see = enemy:see(npc) or mem_time and tg - mem_time <= 7000
	self:set_item(npc,enemy,ene_pos,see,dist)
	
	if (self.st.nodes) then
		if not (see) then
			self:iterate_nodes()
			return
		else 
			self.st.nodes = nil
		end
	end
	
	-- Keep current target vertex id for short duration
	if (self.st.vid and self.st.__keep_point_until and tg < self.st.__keep_point_until) then 
		self.st.vid = utils.send_to_nearest_accessible_vertex(npc,self.st.vid, "axr_new_combat")
		return
	end
	self.st.vid = nil
	
	self:high_level_ai_execute(npc,enemy,ene_pos,see,dist)
end

function action_new_combat:hit_callback(obj, amount, local_direction, who, bone_index)
	if (amount > 0 and who and obj:relation(who) >= game_object.enemy) then 
		self.st.__keep_target_until = tg + 7000
		self.st.target_id = who:id()	
	end
end

function action_new_combat:finalize()
    action_base.finalize(self)
	self.object:set_item(object.idle,self.st.bw or self.object:best_weapon())
	self.st.bw = nil
end

--------------------------------------------------------------------
--------------------------------- BINDER ---------------------------
function setup_generic_scheme(npc,ini,scheme,section,stype,temp)
	local st = xr_logic.assign_storage_and_bind(npc,ini,"new_combat",section,temp)
end

function add_to_binder(npc,ini,scheme,section,storage,temp)
	local manager = npc:motivation_action_manager()
	
	if (character_community(npc) == "zombied" or npc:section() == "actor_visual_stalker") then
		manager:add_evaluator(evaid,property_evaluator_const(false))
		temp.needs_configured = false
		return 
	end

	manager:add_evaluator(evaid,evaluator_new_combat(npc,"eva_new_combat",storage))
	
	temp.action = action_new_combat(npc,"act_new_combat",storage)
	
	temp.action:add_precondition(world_property(stalker_ids.property_alive,true))
	temp.action:add_precondition(world_property(stalker_ids.property_danger, false))
	temp.action:add_precondition(world_property(evaid,true))
	
	temp.action:add_effect(world_property(evaid,false))
	
	manager:add_action(actid,temp.action)
	
	xr_logic.subscribe_action_for_events(npc, storage, temp.action)
end

function configure_actions(npc,ini,scheme,section,stype,temp)
	temp.action:add_precondition(world_property(xr_evaluators_id.sidor_wounded_base,false))
	temp.action:add_precondition(world_property(xr_evaluators_id.wounded_exist,false))

	if (rx_ff) then 
		temp.action:add_precondition(world_property(rx_ff.evid_dont_shoot,false))
	end
	if (rx_gl) then
		temp.action:add_precondition(world_property(rx_gl.evid_gl_reload,false))
	end
	if (xrs_facer) then
		temp.action:add_precondition(world_property(xrs_facer.evid_facer,false))
	end

	local manager = npc:motivation_action_manager()
	local action
	local p = {stalker_ids.action_combat_planner,xr_actions_id.state_mgr + 2,xr_actions_id.alife}
	
	for i=1,#p do
		action = manager:action(p[i])
		if (action) then
			action:add_precondition(world_property(evaid,false))
		else
			printf("axr_new_combat: no action id p[%s]",i)
		end
	end
end 

function disable_generic_scheme(npc,scheme,stype)
	local st = db.storage[npc:id()][scheme]
	if st then
		st.enabled = false
	end
end

function npc_add_precondition(action)
	action:add_precondition(world_property(evaid,false))
end
