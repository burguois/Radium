-----------------------------------------------------------------------------------
-- Monster binding
-----------------------------------------------------------------------------------

function bind(obj)
	--printf("_bp: monster.bind: name='%s', id='%s'", obj:name(), obj:id())

	-- Для спауна
	--xr_spawner.spawn_client(obj)
	local new_binder = generic_object_binder(obj)
	obj:bind_object(new_binder)
end

local last_update = 0 -- combat
------------------------------------------------------------------------------------
class "generic_object_binder" (object_binder)
function generic_object_binder:__init(obj) super(obj)
	self.loaded = false
end

function generic_object_binder:reinit()
	--alun_utils.debug_write(self.object:name().."re_init() Start")
	object_binder.reinit(self)

	db.storage[self.object:id()] = db.storage[self.object:id()] or {}
	self.st = db.storage[self.object:id()]

	if (self.object:alive()) then
		self.object:set_callback(callback.patrol_path_in_point, self.waypoint_callback, self)
		self.object:set_callback(callback.hit,					self.hit_callback,		self)
		self.object:set_callback(callback.death,				self.death_callback,	self)
		self.object:set_callback(callback.sound, 				self.hear_callback, 	self)
	end
	
	--alun_utils.debug_write(self.object:name().."re_init() End")
end

local alife = alife
function generic_object_binder:update(delta)
	--alun_utils.debug_write(alun_utils.sr("%s:update  loaded=%s",self.object and self.object:name(),self.loaded))
	object_binder.update(self, delta)
	
	local object_alive = self.object:alive()
	
	-- update squad
	if (object_alive) then
		self.squad = self.squad or get_object_squad(self.object)
		if (self.squad) then
			if (self.squad:commander_id() == self.object:id()) then 
				self.squad:update()
			end
		end
	end
	
	local tg = time_global()
	if (self.last_update and tg < self.last_update) then
		return
	end
	self.last_update = tg + 500
	
	local id = self.object:id()

	-- Start [Alundaio]
	if (axr_main) then axr_main.monster_on_update(self.object,self.st) end
	-- End [Alundaio]

	if not object_alive then
		local looted = xr_logic.pstor_retrieve(self.object,"looted",nil)
		if not (looted) then
			self.object:set_callback(callback.use_object, self.use_callback, self)
			self.object:set_tip_text("Field Dress")
		else
			self.object:set_callback(callback.use_object, nil)
			self.object:set_tip_text("")
		end
		return
	end

	self.object:set_tip_text("")
	
	if self.st ~= nil and self.st.active_scheme ~= nil then
		xr_logic.try_switch_to_another_section(self.object, self.st[self.st.active_scheme], db.actor)
	end

	if self.object:get_enemy() then
		xr_logic.mob_release(self.object)
		return
	else 
		xr_combat_ignore.fighting_with_actor_npcs[id] = nil
	end

	if self.st.active_section ~= nil then
		xr_logic.issue_event(self.object, self.st[self.st.active_scheme], "update", delta)
		return
	end
	
	if self.squad and self.squad.current_action and self.squad.current_action == 0 then
		local squad_target = self.squad.assigned_target_id and simulation_objects.get_sim_obj_registry().objects[self.squad.assigned_target_id]
		if not (squad_target) then
			return 
		end

		local target_pos, target_lv_id, target_gv_id = squad_target:get_location()
		
		xr_logic.mob_capture(self.object, true)

		if (self.squad:commander_id() == id) then
			action(self.object, move(move.walk_with_leader, target_pos),cond(cond.move_end))
		else
			local sim = alife()
			local commander = sim:object(self.squad:commander_id())
			local commander_pos = commander and commander.position
			if (commander_pos and commander_pos:distance_to(self.object:position()) > 10) then
				action(self.object, move(move.run_with_leader, target_pos),cond(cond.move_end))
			else
				action(self.object, move(move.walk_with_leader, target_pos),cond(cond.move_end))
			end
		end
		return
	end
end

function generic_object_binder:extrapolate_callback()
	--alun_utils.debug_write(alun_utils.sr("%s:extrapolate_callback START",self.object and self.object:name()))
	-- Проверяем, что объект еще в онлайне
	local st = 	db.storage[self.object:id()]
	if (st == nil or st.object == nil) then
		--alun_utils.debug_write(alun_utils.sr("%s:extrapolate_callback end",self.object and self.object:name()))
		return
	end

	local cur_pt = self.object:get_current_point_index()
	if self.object:get_script()	== false then
		--alun_utils.debug_write(alun_utils.sr("%s:extrapolate_callback end",self.object and self.object:name()))
		return false
	end

	local patrol_path = self.object:patrol()
	if not level.patrol_path_exists(patrol_path) then
		--alun_utils.debug_write(alun_utils.sr("%s:extrapolate_callback end",self.object and self.object:name()))
		return false
		--printf("bind_monster:extrapolate_callback(). There is no patrol path [%s]", tostring(patrol_path))
	end
	if patrol(patrol_path):flags(cur_pt):get() == 0 then
		--alun_utils.debug_write(alun_utils.sr("%s:extrapolate_callback end",self.object and self.object:name()))
		return true
	end
	--printf("_bp: generic_object_binder: extrapolate_callback: cur_pt = %d: false", cur_pt)
	--alun_utils.debug_write(alun_utils.sr("%s:extrapolate_callback end",self.object and self.object:name()))
	return false
end

function generic_object_binder:waypoint_callback(obj, action_type, index)
	if self.st.active_section ~= nil then
		xr_logic.issue_event(self.object, self.st[self.st.active_scheme], "waypoint_callback", obj, action_type, index)
	end
end

function generic_object_binder:death_callback(victim, who)
	--alun_utils.debug_write(alun_utils.sr("%s:death_callback killer=%s",self.object and self.object:name(),who and who:name()))
	local id = self.object:id()
	xr_combat_ignore.fighting_with_actor_npcs[id] = nil

	local se_obj = alife():object(id)
	if not (se_obj) then
		return
	end
	
	db.delete_enemy(self.object)

	-- This is necessary because hit callback is not triggered if it takes a single blow to kill npc
	self:hit_callback(victim, 1, vector():set(0,0,0), who, "from_death_callback")

	if (who:id() == db.actor:id()) then
		xr_statistic.inc_killed_monsters_counter()
		xr_statistic.set_best_monster(self.object)
	end

	if self.st.mob_death then
		xr_logic.issue_event(self.object, self.st.mob_death, "death_callback", victim, who)
	end

	if self.st.active_section then
		xr_logic.issue_event(self.object, self.st[self.st.active_scheme], "death_callback", victim, who)
	end

	if (self.object:clsid() == clsid.poltergeist_s) then
		alife():release(se_obj, true)
	else
		release_body_manager.get_release_body_manager():moving_dead_body(self.object)
		-- Alundaio
		if (axr_main) then axr_main.monster_on_death_callback(victim,who) end
		db.storage[id].death_time = game.get_game_time()
		db.storage[id].death_by_id = who:id()
		-- End Alundaio
	end
end

function generic_object_binder:hit_callback(obj, amount, local_direction, who, bone_index)
	if (amount <= 0) then
		return
	end

	if(who:id()==db.actor:id()) then
		xr_statistic.set_best_weapon(amount)
	end

	if self.st.hit then
		xr_logic.issue_event(self.object, self.st.hit, "hit_callback", obj, amount, local_direction, who, bone_index)
	end

	-- Alundaio
	if (axr_main) then axr_main.monster_on_hit_callback(obj, amount, local_direction, who, bone_index) end
	-- End Alundaio
end

function generic_object_binder:hear_callback(self, who_id, sound_type, sound_position, sound_power)
	if who_id == self:id() then
		return
	end
	xr_hear.hear_callback(self, who_id, sound_type, sound_position, sound_power)
end

-- fluffy22
function generic_object_binder:use_callback(obj, who)
	-- Alundaio
	if (axr_main) then axr_main.monster_on_actor_use_callback(obj,who) end
	-- Alundaio
end
-- fluffy22

function generic_object_binder:net_spawn(sobject)
	--alun_utils.debug_write("\n----"..sobject:name()..":net_spawn()----",true)
	if not object_binder.net_spawn(self, sobject) then
		--alun_utils.debug_write(sobject:name()..":net_spawn()  FAILURE FAILURE object_binder.net_spawn returned false!!!")
		return false
	end

	local on_offline_condlist = db.storage[self.object:id()] and db.storage[self.object:id()].overrides and db.storage[self.object:id()].overrides.on_offline_condlist
	if on_offline_condlist ~= nil then
		xr_logic.pick_section_from_condlist(db.actor, self.object, on_offline_condlist)
	end

	db.add_obj(self.object)

	-- Alundaio
	if (axr_main) then axr_main.monster_on_net_spawn(self.object) end
	-- Alundaio
	
	if not self.object:alive() then
		--alun_utils.debug_write(sobject:name()..":net_spawn() Moving dead body...")
		release_body_manager.get_release_body_manager():moving_dead_body(self.object,true)
		--alun_utils.debug_write(sobject:name()..":net_spawn() Moving dead body done")
		--alun_utils.debug_write(sobject:name()..":net_spawn()  END")
		
		-- fix for 'Invalid vertex for object'
		if not (sobject.m_level_vertex_id < 4294967295 and self.object:accessible(sobject.m_level_vertex_id)) then
			printf("npc %s has invalid spawning vertex, correcting",sobject:name())
			local v_id = self.object:accessible_nearest(level.vertex_position(sobject.m_level_vertex_id), vector())
			self.object:set_npc_position(level.vertex_position(v_id))
		end
	
		return true
	end
	
	db.add_enemy(self.object)

	local sim = alife()
	local se_obj = sim:object(self.object:id())
	local force_set_position
	if (db.offline_objects[se_obj.id] and db.offline_objects[se_obj.id].level_vertex_id) then
		force_set_position = level.vertex_position(db.offline_objects[se_obj.id].level_vertex_id)
	elseif se_obj.m_smart_terrain_id ~= 65535 then
		local smart = sim:object(se_obj.m_smart_terrain_id)
		if (smart and not smart.disabled) then
			if not (smart.arriving_npc[se_obj.id]) then
				if (smart.npc_info[se_obj.id] and smart.npc_info[se_obj.id].job) then
					local smart_task = smart.npc_info[se_obj.id].job.alife_task
					force_set_position = smart_task and smart_task:position() or nil
				end
			end
		end
	elseif db.spawned_vertex_by_id[se_obj.id] ~= nil then
		force_set_position = level.vertex_position(db.spawned_vertex_by_id[se_obj.id])
		db.spawned_vertex_by_id[se_obj.id] = nil
	end

	if (force_set_position) then 
		self.object:set_npc_position(force_set_position)
		db.offline_objects[se_obj.id].level_vertex_id = nil
	end
	
	smart_terrain.setup_gulag_and_logic_on_spawn( self.object, self.st, sobject, modules.stype_mobile, self.loaded)

	--alun_utils.debug_write(sobject:name()..":net_spawn()  END")
	return true
end

function generic_object_binder:net_destroy()
	self.object:set_callback(callback.death,				nil)
	self.object:set_callback(callback.patrol_path_in_point, nil)
	self.object:set_callback(callback.hit,					nil)
	self.object:set_callback(callback.sound, 				nil)
	xr_sound.stop_sounds_by_id(self.object:id())

	xr_combat_ignore.fighting_with_actor_npcs[self.object:id()] = nil

	local st = db.storage[self.object:id()]
	if st and st.active_scheme then
		xr_logic.issue_event(self.object, st[st.active_scheme], "net_destroy")
	end

	-- Запоминаем позицию и активную секцию --------
	if db.offline_objects[self.object:id()] then
		db.offline_objects[self.object:id()].level_vertex_id = self.object:level_vertex_id()
		db.offline_objects[self.object:id()].active_section = db.storage[self.object:id()].active_section
	end

	db.del_obj(self.object)
	db.delete_enemy(self.object)
	db.storage[self.object:id()] = nil
	object_binder.net_destroy(self)
end

function generic_object_binder:reload(section)
	--printf("start generic_object_binder:reload(): self.object:name()='%s' section=%s", self.object:name(),section)
	--alun_utils.debug_write(alun_utils.sr("--------%s:reload START",self.object and self.object:name()))
	object_binder.reload(self, section)
	--alun_utils.debug_write(alun_utils.sr("--------%s:reload END",self.object and self.object:name()))
	--printf("end generic_object_binder:reload(): self.object:name()='%s' section=%s", self.object:name(),section)
end

function generic_object_binder:net_save_relevant()
	--printf("generic_object_binder:net_save_relevant(): self.object:name()='%s'", self.object:name())
	return true
end

function generic_object_binder:save(packet)
	--alun_utils.debug_write("\n-------bind_monster save start------ "..self.object:name(),true)
	set_save_marker(packet, "save", false, "generic_object_binder")
	if not (self.object:alive()) then
		alun_utils.w_stpk(packet,"CTime",db.storage[self.object:id()].death_time or game.get_game_time(),self.object:name()..":generic_object_binder:save:GAMETIME")
	end
	object_binder.save(self, packet)
	xr_logic.save_obj(self.object, packet)
	set_save_marker(packet, "save", true, "generic_object_binder")
	--alun_utils.debug_write("\n-------bind_monster save END----------"..self.object:name(),true)
end

function generic_object_binder:load(reader)
	--alun_utils.debug_write("\n-------bind_monster load start------ "..self.object:name(),true)
	self.loaded = true
	set_save_marker(reader, "load", false, "generic_object_binder")
	if not (self.object:alive()) then
		db.storage[self.object:id()].death_time = utils.r_CTime(reader,"bind_monster")
	end
	object_binder.load(self, reader)
	xr_logic.load_obj(self.object, reader)
	set_save_marker(reader, "load", true, "generic_object_binder")
	--alun_utils.debug_write("\n--------bind monster load END -------"..self.object:name())
end

